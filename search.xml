<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apt-get 软件安装那些事儿]]></title>
    <url>%2F2018%2F11%2F28%2Fapt-get%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[对于初次接触Linux的我来说，要想在Ubuntu系统上熟练地安装、升级、卸载软件，确实是挺考验人的一件事，会遇到各种各样的问题，有时候会把我搞得很不耐烦，打击我的学习积极性。Ubuntu一般使用apt-get命令 (ubuntu16.04版本以后可以使用：apt) 来安装、升级、卸载软件。比如我想安装一个软件，常用下面的命令进行安装：123456$ apt-get install xxx$ apt-get update$ apt-get upgrade 顺利安装还好，但有时候还是会遇到各种各样的问题，虽说有时候能通过互联网解决掉，但是对于 apt-get 如何安装的却不是很清楚，比如什么是软件源，就没有啥概念。然后就有了这篇文章。 想要了解apt-get的工作原理，首先我们要明白软件的安装是怎么回事。我们知道一个程序的运行，一般是要先加载(load)到内存(RAM)中，因为RAM存储器支持随机读写，因此CPU可以一条一条地去取指令、翻译指令、运行指令。但是RAM有一个缺点，就是断电后数据会消失，无法保存。因此，我们需要将程序文件保存到一个非易失性存储器上，比如硬盘、NAND Flash上，断电后数据也可以保存。把程序保存到磁盘上的过程其实就是软件的安装过程，早期的单片机裸机环境，程序一般都是使用专门的工具直接烧写到Flash上的，后来有了OS和文件系统，我们可以很方便的通过鼠标，直接将程序文件安装到某个文件目录下面，程序在运行时，系统就可以直接到这个目录下面找到对应的二进制文件，加载到内存，然后就可以直接运行了。 无论是Windows还是Linux，基本流程都是如此：告诉系统你的程序二进制文件存放到哪里了，然后程序在运行时，系统就会到这个指定的路径下面去找你要运行的二进制程序文件，加载到内存，然后运行。在Windows下面，你安装好软件后，在桌面上会有一个快捷方式，其实就是指向你安装路径的软链接。在Linux环境下面，我们要运行的程序一般是放在默认的路径下面的，如:/bin、/sbin、/usr/bin、/usr/sbin等。比如你在shell下面运行：$ ls 命令时，系统就会到这些默认的路径下面去寻找ls文件，在/bin/ls下面找到后，就会加载到内存，然后 ls 程序就可以运行了。 我们写一个简单的helloworld程序，编译为a.out，我们可以直接运行它：1$ ./a.out 为什么不能直接运行$ a.out呢，因为我们的a.out没有安装到默认路径，因此运行时，你要指定路径信息，否则系统就找不到。你把a.out放到默认的/usr/bin下面，然后就可以直接通过$ a.out文件名去执行程序了。当然，你可以可以把自己编译的a.out二进制文件放在自定义的某个目录下面，然后以环境变量的形式告诉系统这个安装路径，当系统在那些默认路径下面找不到时，会到这个安装路径下查找。 我们在Linux环境下安装软件时，最简单的方法是从网上下载这个二进制程序文件，放到Linux系统中的默认路径下面就可以了。但是有些程序是采用动态链接编译的，运行时需要依赖一些动态共享库，因此需要打包一起安装。我们下载的软件一般很少是一个单纯的二进制文件，而是压缩包的形式，在这个压缩包里有：二进制程序文件、动态链接库、软件文档说明、安装信息、甚至有一些自动安装的脚本等。在 Debian 和 Ubuntu 环境下，这个压缩包格式为deb格式，我们安装软件时，先从网上下载对应的deb包，然后可以使用dpkg工具去解析这个包、安装这个包。12345$ dpkg -i xxx.deb 安装xxx.deb软件包$ dkpg -R /home/xxx 安装xxx目录下的多个deb包$ dkpg -r xxx 卸载xxx软件包 当然你也可以将自己的二进制程序制作成一个deb安装包，放到网上，供其他人下载安装：123456789$ apt install checkinstall dh-make$ ./configure --prefix=/home/tools //配置编译信息$ make //编译你的程序$ checkinstall //制作deb包$ dkp -i xxx.deb //安装deb包 因为每个人都可以编译、制作deb包、并随意发布到网上，这就很容易造成混乱，鱼龙混杂、质量得不到保证，甚至有些包还有可能是一个病毒软件。因此Ubuntu系统采用一个软件仓库来管理这些deb软件包，把这些包放到一个官方的网站服务器上，类似于苹果系统的APP store，用户使用apt命令安装软件时，只能到这个服务器上下载软件。考虑到全球各个地方的网络环境差异，往往会在全球各地同时配置几个镜像服务器，这样全球各地的Ubuntu用户都可以根据网络状况到最合适的服务器上去下载和安装deb软件包了。这些服务器我们也称为软件源 (Reposity) 或者简称为“源”。 这些服务器的网络地址保存在/etc/apt/source.list文件中。文件内容如下所示：1deb http://us.archive.ubuntu.com/ubuntu/ xenial universe 当我们使用apt install安装软件时，apt工具就会根据这个source.list文件中的网络地址，选择最合适的服务器去下载软件包。 一般Ubuntu默认的软件源是Ubuntu官方网站，打开上面的网址，你会发现上面存有很多软件包的信息。 对于国内用户来说，访问国外的网站速度可能会慢很多、甚至无法访问。国内高校和互联网公司其实也有很多服务器提供下载，大家百度搜索一下：阿里云软件源、中科大软件源，一般都会搜索到很多服务器地址，可以选择其中几个，添加到/etc/apt/source.list文件中，以后使用apt-get安装软件时，就可以直接从国内的服务器上直接下载deb包了，速度会快很多。 修改好/etc/apt/source.list文件后，你还需要使用$ apt-get update命令更新一下。这个命令的作用访问 /etc/apt/source.list 文件中的每一个服务器，读取可以支持下载安装的软件列表，并保存到本地电脑中(/var/lib/apt/lists)。这个列表就像饭店里的菜单一样，要按照菜单去点菜，直接使用apt install xxx 就可以直接安装软件了。如果你要安装的软件如果不在软件列表中，很可能就安装失败。 软件列表的另一个作用是可以帮助你软件更新，因为服务器上的软件版本也会不断更新，你本地已经安装的软件如果跟软件列表中的软件版本不一致，它可能就会提示你软件需要更新，就像我们PC中的软件管家一样，它会提示你，你的电脑中有多少个软件可以更新。 接下来，如果你想更新这些已经安装的软件，就可以通过$ apt-get upgrade命令来完成。这个命令会将本地已经安装的软件与刚刚使用update命令下载到本地的软件列表进行对比，如果发现版本不一致，就会重新安装最新的版本。如果你的系统需要更新的软件包太多，这个可能需要一定的时间，耐心等待就可以了，升级成功后，一般会有提示信息，你升级了多少个软件包… 使用apt安装软件的另一个好处是可以自动处理依赖关系。比如你想安装一个B，需要依赖A，那么你安装B的同时，B所依赖的A软件包也会自动安装上了。在/var/lib/dpkg/available文件中，有详细的软件包信息，包括软件版本、软件依赖的包等。包括在视频教程《使用QEMU搭建嵌入式U-boot+Linux+NFS开发环境》中，很多学员反馈说，为什么我的环境跟视频中的不一样？这是因为每个Ubuntu版本不同、安装的软件不同，安装的库、头文件也不一样，大家在编译的时候如果遇到一些无法识别的命令、缺少一些头文件，直接安装对应的工具和库就可以了，随着你的Ubuntu系统安装的一些依赖库、工具越来越多，以后再编译其它软件时，一般都可以顺利编译了，因为很多依赖的库文件、头文件、工具、命令等都安装得差不多了。 对于一个新手。在使用apt-get安装软件时，经常遇到的问题很多，比如权限不够，使用sudo、或切换到root安装可以解决这个问题。无法获取软件包，网络访问不了，可以在/etc/apt/source.list文件中添加国内的一些镜像服务器地址(软件源)。还有一个经常遇到的问题是：1E: 无法获得锁 /var/cache/apt/archives/lock 直接删除这个文件就可以了，对应的还有 /var/lib/dpkg/lock文件，顺便也删除掉，一般就可以解决问题。在安装的过程中，如果遇到其它问题，建议先到百度里搜一搜，你遇到的问题、踩到的坑，前面可能已经有无数人遇到过了，看看它们是怎么解决的，一般都可以解决问题。 最后，当你安装的软件在服务器中确实没有时，这就需要你手动下载源码、编译安装了，一般在Linux系统中，可以直接下载GNU工程开源代码，然后直接通过三步走，就可以直接编译和安装了：12345$ ./configure$ make$ make install]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>apt-get</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>apt-get</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python脚本的模块记录]]></title>
    <url>%2F2018%2F11%2F25%2Fpython_os_time%2F</url>
    <content type="text"><![CDATA[一篇python脚本的模块记录，不主张全部记录，一般都是用到什么记录什么。(os模块和time模块) python脚本的模块记录 os time os模块这个模块第一次使用是为了备份一个目录，与系统的沟通依赖于os模块，所以今天整理下比较常用的几个方法。 当前路径及路径下的文件 os.getcwd()：查看当前所在路径。 os.listdir(path):列举目录下的所有文件。返回的是列表类型。 12345&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()&apos;D:\\pythontest\\ostest&apos;&gt;&gt;&gt; os.listdir(os.getcwd())[&apos;hello.py&apos;, &apos;test.txt&apos;] 绝对路径 os.path.abspath(path):返回path的绝对路径。 1234&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;D:\\pythontest\\ostest&apos;&gt;&gt;&gt; os.path.abspath(&apos;..&apos;)&apos;D:\\pythontest&apos; 查看路径的文件夹部分和文件名部分 os.path.split(path):将路径分解为(文件夹,文件名)，返回的是元组类型。可以看出，若路径字符串最后一个字符是\,则只有文件夹部分有值；若路径字符串中均无\,则只有文件名部分有值。若路径字符串有\，且不在最后，则文件夹和文件名均有值。且返回的文件夹的结果不包含. os.path.join(path1,path2,…):将path进行组合，若其中有绝对路径，则之前的path将被删除。 1234567891011121314&gt;&gt;&gt; os.path.split(&apos;D:\\pythontest\\ostest\\Hello.py&apos;)(&apos;D:\\pythontest\\ostest&apos;, &apos;Hello.py&apos;)&gt;&gt;&gt; os.path.split(&apos;.&apos;)(&apos;&apos;, &apos;.&apos;)&gt;&gt;&gt; os.path.split(&apos;D:\\pythontest\\ostest\\&apos;)(&apos;D:\\pythontest\\ostest&apos;, &apos;&apos;)&gt;&gt;&gt; os.path.split(&apos;D:\\pythontest\\ostest&apos;)(&apos;D:\\pythontest&apos;, &apos;ostest&apos;)&gt;&gt;&gt; os.path.join(&apos;D:\\pythontest&apos;, &apos;ostest&apos;)&apos;D:\\pythontest\\ostest&apos;&gt;&gt;&gt; os.path.join(&apos;D:\\pythontest\\ostest&apos;, &apos;hello.py&apos;)&apos;D:\\pythontest\\ostest\\hello.py&apos;&gt;&gt;&gt; os.path.join(&apos;D:\\pythontest\\b&apos;, &apos;D:\\pythontest\\a&apos;)&apos;D:\\pythontest\\a&apos; os.path.dirname(path):返回path中的文件夹部分，结果不包含’\’ 12345678&gt;&gt;&gt; os.path.dirname(&apos;D:\\pythontest\\ostest\\hello.py&apos;)&apos;D:\\pythontest\\ostest&apos;&gt;&gt;&gt; os.path.dirname(&apos;.&apos;)&apos;&apos;&gt;&gt;&gt; os.path.dirname(&apos;D:\\pythontest\\ostest\\&apos;)&apos;D:\\pythontest\\ostest&apos;&gt;&gt;&gt; os.path.dirname(&apos;D:\\pythontest\\ostest&apos;)&apos;D:\\pythontest&apos; os.path.basename(path):返回path中的文件名。 12345678&gt;&gt;&gt; os.path.basename(&apos;D:\\pythontest\\ostest\\hello.py&apos;)&apos;hello.py&apos;&gt;&gt;&gt; os.path.basename(&apos;.&apos;)&apos;.&apos;&gt;&gt;&gt; os.path.basename(&apos;D:\\pythontest\\ostest\\&apos;)&apos;&apos;&gt;&gt;&gt; os.path.basename(&apos;D:\\pythontest\\ostest&apos;)&apos;ostest&apos; 查看文件时间 os.path.getmtime(path):文件或文件夹的最后修改时间，从新纪元到访问时的秒数。 os.path.getatime(path):文件或文件夹的最后访问时间，从新纪元到访问时的秒数。 os.path.getctime(path):文件或文件夹的创建时间，从新纪元到访问时的秒数。 123456&gt;&gt;&gt; os.path.getmtime(&apos;D:\\pythontest\\ostest\\hello.py&apos;)1481695651.857048&gt;&gt;&gt; os.path.getatime(&apos;D:\\pythontest\\ostest\\hello.py&apos;)1481687717.8506615&gt;&gt;&gt; os.path.getctime(&apos;D:\\pythontest\\ostest\\hello.py&apos;)1481687717.8506615 查看文件大小 os.path.getsize(path):文件或文件夹的大小，若是文件夹返回0。 1234&gt;&gt;&gt; os.path.getsize(&apos;D:\\pythontest\\ostest\\hello.py&apos;)58L&gt;&gt;&gt; os.path.getsize(&apos;D:\\pythontest\\ostest&apos;)0L 查看文件是否存在 os.path.exists(path):文件或文件夹是否存在，返回True 或 False。 123456789&gt;&gt;&gt; os.listdir(os.getcwd())[&apos;hello.py&apos;, &apos;test.txt&apos;]&gt;&gt;&gt; os.path.exists(&apos;D:\\pythontest\\ostest\\hello.py&apos;)True&gt;&gt;&gt; os.path.exists(&apos;D:\\pythontest\\ostest\\Hello.py&apos;)True&gt;&gt;&gt; os.path.exists(&apos;D:\\pythontest\\ostest\\Hello1.py&apos;)False 调用系统命令 os.system()和os.popen() os.system() 12345&gt;&gt;&gt; help(os.system)Help on built-in function system in module nt:system(command) Execute the command in a subshell. 从字面意思上看，os.system()是在当前进程中打开一个子shell（子进程）来执行系统命令。官方说法：123On Unix, the return value is the exit status of the process encoded in the format specified for wait().The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. 这个方法会直接返回执行结果，以及状态码。不过官方建议使用subprocess模块来生成新进程并获取结果是更好的选择。123&gt;&gt;&gt; os.system(&apos;ls&apos;)access.log douban.py mail.py myapp.py polipo proxychains __pycache__ spider.py test.py users.txt0 os.popen() 12345&gt;&gt;&gt; help(os.popen)Help on function popen in module os:popen(cmd, mode=&apos;r&apos;, buffering=-1) # Supply os.popen() cmd：要执行的命令。mode：打开文件的模式，默认为’r’，用法与open()相同。buffering：0意味着无缓冲；1意味着行缓冲；其它正值表示使用参数大小的缓冲。负的bufsize意味着使用系统的默认值，一般来说，对于tty设备，它是行缓冲；对于其它文件，它是全缓冲。 官方说法： 12345Open a pipe to or from command cmd. The return value is an open file object connected to the pipe, which can be read or written depending on whether mode is &apos;r&apos; (default) or &apos;w&apos;. The close method returns None if the subprocess exited successfully, or the subprocess’s return code if there was an error. This is implemented using subprocess.Popen; 这个方法会打开一个管道，返回结果是一个连接管道的文件对象，该文件对象的操作方法同open()，可以从该文件对象中读取返回结果。如果执行成功，不会返回状态码，如果执行失败，则会返回错误信息。这里官方也表示subprocess模块已经实现了更为强大的subprocess.Popen()方法。123456789&gt;&gt;&gt; os.popen(&apos;ls&apos;)&lt;os._wrap_close object at 0x7f93c5a2d780&gt;&gt;&gt;&gt; os.popen(&apos;la&apos;)&lt;os._wrap_close object at 0x7f93c5a37588&gt;&gt;&gt;&gt; /bin/sh: la: command not found&gt;&gt;&gt; f = os.popen(&apos;ls&apos;)&gt;&gt;&gt; type(f)&lt;class &apos;os._wrap_close&apos;&gt; 读取执行结果：12&gt;&gt;&gt; f.readlines()[&apos;access.log\n&apos;, &apos;douban.py\n&apos;, &apos;import_test.py\n&apos;, &apos;mail.py\n&apos;, &apos;myapp.py\n&apos;, &apos;polipo\n&apos;, &apos;proxychains\n&apos;, &apos;__pycache__\n&apos;, &apos;spider.py\n&apos;, &apos;test.py\n&apos;, &apos;users.txt\n&apos;] time 模块 time.strftime(format[,t]) 把一个代表时间的元组或者struct_time(如由time.localtime()和time.gmtime()返回)转化为格式化的时间字符串．如果t未指定，将传入time.localtime()，如果元组中任命一个元素越界，将会抛出ValueError异常 format格式如下： 操作符 作用 %a 本地(local)简化星期名称 %A 本地完整星期名称 %b 本地简化月份名称 %B 本地完整月份名称 %c 本地相应的日期和时间表示 %d 一个月中的第几天(01-31) %H 一天中的第几个小时(24小时制，00-23) %l 一天中的第几个小时(12小时制，01-12) %j 一年中的第几天(01-366) %m 月份(01-12) %M 分钟数(00-59) %p 本地am或者pm的相应符 %S 秒(01-61) %U 一年中的星期数(00-53,星期天是一个星期的开始,第一个星期天之前的所有天数都放在第０周) %w 一个星期中的第几天(0-6,0是星期天) %W 和%U基本相同，不同的是%W以星期一为一个星期的开始 %x 本地相应日期 %X 本地相应时间 %y 去掉世纪的年份(00-99) %Y 完整的年份 %z 用+HHMM或者-HHMM表示距离格林威治的时区偏移(H代表十进制的小时数，M代表十进制的分钟数) %Z 时区的名字(如果不存在为空字符) %% %号本身， %p只有与%I配合使用才有效果，当使用strptime()函数时，只有当在这年中的周数和天数被确定的时候%U和%W才会被计算]]></content>
      <categories>
        <category>python</category>
        <category>学习，模块</category>
      </categories>
      <tags>
        <tag>备份,脚本,python,os,time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树梅派的配置文件config.txt]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84config.txt%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[树莓派的配置界面图，类似于PC上bios，只是PC上的存在一块芯片上，而树莓派对应的是config.txt文件。 树莓派配置文件config.txt详细介绍: 官方文档：Rconfig 由于树莓派并没有传统意义上的BIOS, 所以现在各种系统配置参数通常被存在”config.txt”这个文本文件中，树莓派的config.txt文件会在ARM内核初始化之前被GPU读取。这个文件存在引导分区上的，对于Linux, 路径通常是/boot/config.txt, 如果是Windows (或者OS X) 它会被识别为SD卡中可访问部分的一个普通文件. 将树莓派SD卡通过读卡器接到电脑上，就可以修改这个文件。 如果你将树莓派通过HDMI连接到显示器上，但是显示器黑屏无法正常显示，这是由于配置参数和显示器不匹配的原因，因此，必须修改树莓派配置文件config.txt。解决方案可以参考这篇文章：解决树莓派使用HDMI-VGA转换器黑屏的方案 。 一、显示配置 hdmi_safe 使用”安全模式”的设置去尝试用HDMI最大兼容性启动. 这和下面的组合是一个意思: hdmi_force_hotplug=1, config_hdmi_boost=4, hdmi_group=2, hdmi_mode=4, disable_overscan=0hdmi_safe=1hdmi_ignore_edid 如果你的显示器是天朝产的垃圾货, 允许系统忽略EDID显示数据hdmi_ignore_edid=0xa5000080hdmi_edid_file 当设为1时, 将会从edid.dat文件中读取EDID数据，而不是从显示器.[1]hdmi_edid_file=1hdmi_force_edid_audio 伪装成支持所有音频格式播放, 即便报告不支持也允许通过DTS/AC3.hdmi_force_edid_audio=1hdmi_force_edid_3d 伪装成全部CEA模式都支持3D, 即便EDID并不支持.hdmi_force_edid_3d=1avoid_edid_fuzzy_match 禁止去模糊匹配EDID中描述的模式. 即便遮蔽错误, 也选用匹配分辨率和最接近帧率的标准模式.avoid_edid_fuzzy_match=1hdmi_ignore_cec_init 不发送初始化激活源消息. 避免在重启时使(启用CEC)TV结束待机并切换频道.hdmi_ignore_cec_init=1hdmi_ignore_cec 伪装成TV不支持CEC. 将不会支持任何CEC功能.hdmi_ignore_cec=1hdmi_force_hotplug 伪装成HDMI热插拔信号被检测到, 出现HDMI显示器被接入hdmi_force_hotplug=1 即便没有检测到HDMI显示器也要使用HDMI模式hdmi_ignore_hotplug 伪装成HDMI热插拔信号没有被检测到, 出现HDMI显示器未接入hdmi_ignore_hotplug=1 即便检测到HDMI显示器也要使用混合模式hdmi_pixel_encoding 强制像素编码模式. 默认情况下会使用EDID请求的模式, 所以不需要修改.12345hdmi_pixel_encoding=0 default (limited for CEA, full for DMT) hdmi_pixel_encoding=1 RGB limited (16-235) hdmi_pixel_encoding=2 RGB full ( 0-255) hdmi_pixel_encoding=3 YCbCr limited (16-235) hdmi_pixel_encoding=4 YCbCr limited ( 0-255) hdmi_drive 选择HDMI还是DVI模式12hdmi_drive=1 DVI模式 (没声音) hdmi_drive=2 HDMI模式 (如果支持并已启用将有声音输出) hdmi_group 设置HDMI类型不指定组, 或者设为0, 将会使用EDID报告的首选组.12hdmi_group=1 CEAhdmi_group=2 DMT hdmi_mode 设置在CEA或DMT格式下的屏幕分辨率123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263当hdmi_group=1 (CEA)时,下列值有效 hdmi_mode=1 VGAhdmi_mode=2 480p 60Hzhdmi_mode=3 480p 60Hz Hhdmi_mode=4 720p 60Hzhdmi_mode=5 1080i 60Hzhdmi_mode=6 480i 60Hzhdmi_mode=7 480i 60Hz Hhdmi_mode=8 240p 60Hzhdmi_mode=9 240p 60Hz Hhdmi_mode=10 480i 60Hz 4xhdmi_mode=11 480i 60Hz 4x Hhdmi_mode=12 240p 60Hz 4xhdmi_mode=13 240p 60Hz 4x Hhdmi_mode=14 480p 60Hz 2xhdmi_mode=15 480p 60Hz 2x Hhdmi_mode=16 1080p 60Hzhdmi_mode=17 576p 50Hzhdmi_mode=18 576p 50Hz Hhdmi_mode=19 720p 50Hzhdmi_mode=20 1080i 50Hzhdmi_mode=21 576i 50Hzhdmi_mode=22 576i 50Hz Hhdmi_mode=23 288p 50Hzhdmi_mode=24 288p 50Hz Hhdmi_mode=25 576i 50Hz 4xhdmi_mode=26 576i 50Hz 4x Hhdmi_mode=27 288p 50Hz 4xhdmi_mode=28 288p 50Hz 4x Hhdmi_mode=29 576p 50Hz 2xhdmi_mode=30 576p 50Hz 2x Hhdmi_mode=31 1080p 50Hzhdmi_mode=32 1080p 24Hzhdmi_mode=33 1080p 25Hzhdmi_mode=34 1080p 30Hzhdmi_mode=35 480p 60Hz 4xhdmi_mode=36 480p 60Hz 4xHhdmi_mode=37 576p 50Hz 4xhdmi_mode=38 576p 50Hz 4x Hhdmi_mode=39 1080i 50Hz reduced blankinghdmi_mode=40 1080i 100Hzhdmi_mode=41 720p 100Hzhdmi_mode=42 576p 100Hzhdmi_mode=43 576p 100Hz Hhdmi_mode=44 576i 100Hzhdmi_mode=45 576i 100Hz Hhdmi_mode=46 1080i 120Hzhdmi_mode=47 720p 120Hzhdmi_mode=48 480p 120Hzhdmi_mode=49 480p 120Hz Hhdmi_mode=50 480i 120Hzhdmi_mode=51 480i 120Hz Hhdmi_mode=52 576p 200Hzhdmi_mode=53 576p 200Hz Hhdmi_mode=54 576i 200Hzhdmi_mode=55 576i 200Hz Hhdmi_mode=56 480p 240Hzhdmi_mode=57 480p 240Hz Hhdmi_mode=58 480i 240Hzhdmi_mode=59 480i 240Hz HH表示16:9比例(正常是4:3).2x表示双倍像素(即更高的像素时脉, 每个像素重复两次)4x表示四倍像素(即更高的像素时脉, 每个像素重复四次) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788当hdmi_group=2 (DMT)时,下列值有效 像素时脉是有限制的, 最高支持的模式是1920x1200 @60Hz with reduced blanking.hdmi_mode=1 640x350 85Hzhdmi_mode=2 640x400 85Hzhdmi_mode=3 720x400 85Hzhdmi_mode=4 640x480 60Hzhdmi_mode=5 640x480 72Hzhdmi_mode=6 640x480 75Hzhdmi_mode=7 640x480 85Hzhdmi_mode=8 800x600 56Hzhdmi_mode=9 800x600 60Hzhdmi_mode=10 800x600 72Hzhdmi_mode=11 800x600 75Hzhdmi_mode=12 800x600 85Hzhdmi_mode=13 800x600 120Hzhdmi_mode=14 848x480 60Hzhdmi_mode=15 1024x768 43Hz DO NOT USEhdmi_mode=16 1024x768 60Hzhdmi_mode=17 1024x768 70Hzhdmi_mode=18 1024x768 75Hzhdmi_mode=19 1024x768 85Hzhdmi_mode=20 1024x768 120Hzhdmi_mode=21 1152x864 75Hzhdmi_mode=22 1280x768 reduced blankinghdmi_mode=23 1280x768 60Hzhdmi_mode=24 1280x768 75Hzhdmi_mode=25 1280x768 85Hzhdmi_mode=26 1280x768 120Hz reduced blankinghdmi_mode=27 1280x800 reduced blankinghdmi_mode=28 1280x800 60Hzhdmi_mode=29 1280x800 75Hzhdmi_mode=30 1280x800 85Hzhdmi_mode=31 1280x800 120Hz reduced blankinghdmi_mode=32 1280x960 60Hzhdmi_mode=33 1280x960 85Hzhdmi_mode=34 1280x960 120Hz reduced blankinghdmi_mode=35 1280x1024 60Hzhdmi_mode=36 1280x1024 75Hzhdmi_mode=37 1280x1024 85Hzhdmi_mode=38 1280x1024 120Hz reduced blankinghdmi_mode=39 1360x768 60Hzhdmi_mode=40 1360x768 120Hz reduced blankinghdmi_mode=41 1400x1050 reduced blankinghdmi_mode=42 1400x1050 60Hzhdmi_mode=43 1400x1050 75Hzhdmi_mode=44 1400x1050 85Hzhdmi_mode=45 1400x1050 120Hz reduced blankinghdmi_mode=46 1440x900 reduced blankinghdmi_mode=47 1440x900 60Hzhdmi_mode=48 1440x900 75Hzhdmi_mode=49 1440x900 85Hzhdmi_mode=50 1440x900 120Hz reduced blankinghdmi_mode=51 1600x1200 60Hzhdmi_mode=52 1600x1200 65Hzhdmi_mode=53 1600x1200 70Hzhdmi_mode=54 1600x1200 75Hzhdmi_mode=55 1600x1200 85Hzhdmi_mode=56 1600x1200 120Hz reduced blankinghdmi_mode=57 1680x1050 reduced blankinghdmi_mode=58 1680x1050 60Hzhdmi_mode=59 1680x1050 75Hzhdmi_mode=60 1680x1050 85Hzhdmi_mode=61 1680x1050 120Hz reduced blankinghdmi_mode=62 1792x1344 60Hzhdmi_mode=63 1792x1344 75Hzhdmi_mode=64 1792x1344 120Hz reduced blankinghdmi_mode=65 1856x1392 60Hzhdmi_mode=66 1856x1392 75Hzhdmi_mode=67 1856x1392 120Hz reduced blankinghdmi_mode=68 1920x1200 reduced blankinghdmi_mode=69 1920x1200 60Hzhdmi_mode=70 1920x1200 75Hzhdmi_mode=71 1920x1200 85Hzhdmi_mode=72 1920x1200 120Hz reduced blankinghdmi_mode=73 1920x1440 60Hzhdmi_mode=74 1920x1440 75Hzhdmi_mode=75 1920x1440 120Hz reduced blankinghdmi_mode=76 2560x1600 reduced blankinghdmi_mode=77 2560x1600 60Hzhdmi_mode=78 2560x1600 75Hzhdmi_mode=79 2560x1600 85Hzhdmi_mode=80 2560x1600 120Hz reduced blankinghdmi_mode=81 1366x768 60Hzhdmi_mode=82 1080p 60Hzhdmi_mode=83 1600x900 reduced blankinghdmi_mode=84 2048x1152 reduced blankinghdmi_mode=85 720p 60Hzhdmi_mode=86 1366x768 reduced blanking overscan_left 左侧跳过像素数 overscan_right 右侧跳过像素数 overscan_top 顶部跳过像素数 overscan_bottom 底部跳过像素数 framebuffer_width 控制台framebuffer宽度, 以像素为单位. 默认是显示器宽度减去超出扫描. framebuffer_height 控制台framebuffer高度, 以像素为单位. 默认是显示器高度减去超出扫描. framebuffer_depth 控制台framebuffer深度, 以位为单位. 默认是16位. 8位也是有效的, 但是默认RGB调色板会导致屏幕不可读. 24位效果更好 ,但是2012年6月15号发现有显示混乱问题. 32位没有混乱问题, 但是需要设置framebuffer_ignore_alpha=1, 并在2012年6月15号发现颜色显示错误. framebuffer_ignore_alpha 设为1将禁用alpha通道. 仅对32位有效. test_mode 允许在启动时做声音与图像测试. disable_overscan 设为1将禁用超出扫描. config_hdmi_boost 设置HDMI接口的信号强度. 默认为0. 如果出现HDMI干扰问题可以试试设为4. 最大为7. display_rotate 顺时针旋转屏幕显示 (默认为0) 或者翻转显示. 123456display_rotate=0 正常display_rotate=1 90度display_rotate=2 180度display_rotate=3 270度display_rotate=0x10000 水平翻转display_rotate=0x20000 垂直翻转 二、超频选项这里可以方便的将树莓派超频：使用Raspi-config配置工具来设置树莓派 ，除此之外，也可以修改配置文件config.txt将树莓派超频，可以修改arm_freq选项，默认为700MHz，如果要超频到800MHz，则可以这么修改：arm_freq=800三、使能硬件接口在配置文件的最后，可以开启树莓派的硬件接口，例如：123dtparam=i2c_arm=ondtparam=i2s=ondtparam=spi=on 这样就可以使能树莓派的I2C、SPI接口了。 我的树莓派就是用这篇文章配置的，写的比较详细。收藏到博客，留待参考！ 原作者：然心向往之来源：CSDN原文：https://blog.csdn.net/qq_38880380/article/details/78490186版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>记录</category>
        <category>技巧，常用</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>树梅派</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树梅派安装]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI) [1] 是为学习计算机编程教育而设计)，只有信用卡大小的微型电脑，其系统基于Linux。随着Windows 10 IoT的发布，我们也将可以用上运行Windows的树莓派。自问世以来，受众多计算机发烧友和创客的追捧，曾经一“派”难求。别看其外表“娇小”，内“心”却很强大，视频、音频等功能通通皆有，可谓是“麻雀虽小，五脏俱全”。 [– 来自百度百科] 前言这两天打算买个台式的电脑，但是无奈作为学生党的我没钱（^-^），只能作罢。发愁之际想起大一专业引领课上老师手里的卡片电脑，百度查了下资料。简直完美，这不就我要的吗，LINUX系统、这种编译器又方便折腾，不过这东西我依旧买不起（最新的树莓派3B+ 400大洋），更不说还要那么多的外设要买。想来想去闲鱼买了一个二手的树莓派2B，自己玩的够用了，等以后有钱了一定买个最新的。。。 今天就先把树莓派的配置过程记录下，踩了两天多的坑，才用上树莓派，真心的不容易啊 系统安装系统下载树莓派官网提供很多支持的系统下载，包括windows在内的很多系统。刚开始使用树莓派我打算就使用官方原版系统，原因： 树莓派官原系统是LINUX的发行版，我的博客一直在用ubuntu（LIUNX的一个发行版）更新，上手简单。 官方系统坑少，容易很快配置好。 官方系统资料多，方便学习。 系统写入 SD要格式化，我用的是一个叫SD Card Formatter的软件，放入网盘了，要的时候去找。 用镜像写入软件把下载好的系统镜像写入SD卡，软件Etcher也在我的网盘。 然后把安装系统的SD卡插入树莓派进行连接。 树莓派连接电脑我没有显示器，而且买不起。。。只能用我的电脑了，树莓派有三种方式连接电脑： 串口连接用USB转串口芯片连接树莓派和电脑，一开始我就是这么打算的。但是比较无奈的是我用CH340和树莓派不兼容，PL232和win 10兼容性太差，一开始是检测不到、试了好多个驱动后终于检测到了，但是。。。我的电脑蓝屏了四五次（为避免系统崩溃），无奈之下放弃了这个方法。留待有缘人去折腾，建议不要用win 10 ，我以前用win 7的时候PL232兼容性贼好。 SSH登陆设置好树莓派的静态ID，用网线将树莓派和路由器LAN口相连，然后就可以远程操作我们的树莓派了。但是得注意，我们得和树莓派在同一个wifi频段上。也就是我们电脑得连接树莓派所连接的路由器的wifi，不然连不上。 网线直连因为树莓派2B只有一个能用的串口，另外一个串口还是虚拟的，这就很揪心了。你可以通过ssh登录，然后使用其串口。我用树莓派和电脑通过一根网线连接也做到了，网上有很多教程。 用网线连接树莓派的电脑并且把电脑的网络共享给树莓派的网口。 在dos界面输入arp -a，会奇怪地多出个192.168.137.1，而且每台电脑都一样，这是本地连接的IP地址，把电脑看成一个路由器，地址为192.168.137.1，然后你树莓派的IP在其频段下设置。这个时候你就可以看到树莓派的IP了，一般后面是以b开头的。 然后你打开secureCRT或者PUTTY，通过SSH登录进去，就OK了。 唉。。。这个地方卡了我整整一天，都想到放弃了（差点就吃土买显示器），最后还是找到办法了。原因是这样的，我在官网下载到的系统然后写入SD卡、开机、SSH连接，然后，emmmmm没有一点点反应，我去~~~后来吧，我找了大量资料终于发现一个问题，树莓派官方为了支持树莓派3的板载蓝牙功能，关闭了SSH功能。我心里把那个无奈啊，再后来吧，我找了好多的论坛，终于找到了一个2015年的树莓派系统，简直完美啊有木有，果断安装，运行，SSH登陆，成功！！！ 最后，我又一次充满了斗气，折腾的路上永不止息！]]></content>
      <categories>
        <category>折腾</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>树梅派</tag>
        <tag>记录</tag>
        <tag>卡片电脑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的动态储存空间分配]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A8%E6%80%81%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在程序设计和编制时不知道数据的数量,在程序运行时确定了数据的数量后再为其分配存储空间，具有灵活,易扩展的优点。 核心思想利用指针控制储存空间大小 核心例程:12345678910int Num, i, *pMyIntArray; // 定义一个指针变量cout &lt;&lt; endl &lt;&lt; “输入数据的数量”;cin &gt;&gt; Num;pMyIntArray = (int*)malloc(Num*sizeof(int));for (i=0; i&lt;Num; i++) &#123; cout &lt;&lt; endl; cout &lt;&lt; &quot;输入第 &quot; &lt;&lt; i+1 &lt;&lt; &quot; 个数据:&quot;; cin &gt;&gt; pMyIntArray[i]; &#125; 动态存储空间分配的常用函数和注意事项 常用函数: void *malloc(size_t size)—分配size字节空间,内容随机。void *calloc(size_t num, size_t size)—分配num个size字节空间,内容清零。void *realloc(void *memblock, size_t size)—重新为memblock分配空间,使其大小为size,其位置可能会移动。void free(void *memblock)释放为指针变量memblock分配的空间。 注意事项:要将分配函数的返回值强制类型转换为指定类型的指针;并检查返回值是否为NULL,若是表示存储空间不够;所有存储空间用完后要释放掉。 我们计算机软件老师PPT上摘录的，感觉挺有用的就记录下来，说定有用。]]></content>
      <categories>
        <category>C语言</category>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是怎么找到电子书的]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[不论是娱乐用的、还是专业数据，我都能找得着，就是因为这些网站啦！ 电子出版物IT-ebookshttp://it-ebooks.info/ 上万本英文原版电子书，大多数为apress和o&#39;relly的。全都是文字版，体积小又清楚。适合懂英文的人看。 脚本之家电子书http://www.jb51.net/books/ 很多扫描版的电子书。几乎五年之前出版的都有。 CSDN 下载http://download.csdn.net/ 51CTO 下载http://down.51cto.com/ 百度云http://pan.baidu.com/ 百度云没有内置搜索，可以使用胖次百度网盘搜索引擎。 微盘http://vdisk.weibo.com/ 微盘是内置搜索的。而且之前新浪爱问共享的数据都搬过来了。 图灵社区电子书http://www.ituring.com.cn/book/ebook 图灵社区会把一些电子书免费发放出来。其他的书是收费的，只免费几章。不过大家也可以买电子版支持一下，毕竟电子版远没有实体书贵。 免费电子书免费的编程中文书籍索引https://github.com/justjavac/free-programming-books-zh_CN 由@justjavac（迷渡）整理的一份免费编程图书列表，存放于github上，自己有书需要共享可以投稿。 reSRChttp://resrc.io/list/10/list-of-free-programming-books/ stackoverflow上一位大牛整理的免费电子书列表，英文版。 wikibookswikibooks是一个免费电子书公益项目，由那些抱怨课本太贵的美国教育界人物发起并支持。其中有一些是计算机图书。 http://en.wikibooks.org/wiki/Subject:Computing GitBookhttps://www.gitbook.com/explore]]></content>
      <categories>
        <category>高效率生活</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>电子书</tag>
        <tag>经验</tag>
        <tag>搜索</tag>
        <tag>Seule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傻瓜函数式编程]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%82%BB%E7%93%9C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文及翻译摘自Github@justjavac（迷渡） ============================================2006年6月19日，星期一 开篇我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有RSS订阅的文章。然后翻翻新闻还有那些技术网站上的更新，再过一遍编程论坛口水区里那些无聊的论战。最后从头把这些再看一次以免错过什么精彩的内容。然后就可以吃午饭了。饭饱过后，回来盯着IDE发一会呆，再看看邮箱，再去搞杯咖啡。光阴似箭，可以回家了……（在被众人鄙视之前）我唯一想说的是，在这些拖拉的日子里总会时不时读到一些不明觉厉的文章。如果没有打开不应该打开的网站，每隔几天你都可以看到至少一篇这样的东西。它们的共性：难懂，耗时，于是这些文章就慢慢的堆积成山了。很快你就会发现自己已经累积了一堆的收藏链接还有数不清的PDF文件，此时你只希望隐入一个杳无人烟的深山老林里什么也不做，用一年半载好好的消化这些私藏宝贝。当然，我是说最好每天还是能有人来给送吃的顺带帮忙打扫卫生倒垃圾，哇哈哈。 我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫10年以上的大牛都无法搞懂这些函数式编程（简称FP）文章到底在说什么。你可以去花旗集团或者德意志银行找个项目经理来问问1：你们为什么要选JMS而不用Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。关于FP的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是FP概念本身并不难理解。我希望这篇文章可以成为一个“FP入门指南”，帮助你从指令式编程走向函数式编程。先来点咖啡，然后继续读下去。很快你对FP的理解就会让同事们刮目相看了。 什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹FP的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的closure、continuation，currying，lazy evaluation还有no side effects都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？我们很快就会解开这些谜团。刚才我说过实际工程和学术界之间的知识断层是有其历史原因的，那么就先让我来解释一下这个问题。答案，就在接下来的一次公园漫步中： 公园漫步时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。 “你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。小男仆望向水池旁边的两个男生，“他们差不多一样高。”。“‘差不多一样高’是什么意思？”柏拉图问。“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。”说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解‘完全相等’这个概念？”小男仆看起来很困惑。“这我就不知道了。” 这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。 如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？2数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。 如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子（译者：偶的妈你咋知道？）也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏（译者：那狗可以么？）可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。 历史回眸3再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。 新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。 如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！ 函数式编程函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。所以，就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。有很多支持函数式编程的程序语言，它们之间的具体设计都不完全一样。在这里我将用Java写的例子介绍那些被广泛应用的函数式编程思想（没错，如果你是受虐狂你可以用Java写出函数式程序）。在下面的章节中我会在Java语言的基础上，做一些修改让它变成实际可用的函数式编程语言。那么现在就开始吧。 Lambda演算在最初设计的时候就是为了研究计算相关的问题。所以函数式编程主要解决的也是计算问题，而出乎意料的是，是用函数来解决的！（译者：请理解原作者的苦心，我想他是希望加入一点调皮的风格以免读者在中途睡着或是转台……）。函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式（这样我们就不用把所有的代码都写在同一行里了）。所以我们这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。在Java中就意味着每一个变量都将被声明为final（如果你用C++，就是const）。在FP中，没有非final的变量。 12final int i = 5;final int j = i + 3; 既然FP中所有的变量都是final的，可以引出两个规定：一是变量前面就没有必要再加上final这个关键字了，二是变量就不能再叫做‘变量’了……于是现在开始对Java做两个改动：所有Java中声明的变量默认为final，而且我们把所谓的‘变量’称为‘符号’。到现在可能会有人有疑问：这个新创造出来的语言可以用来写什么有用的复杂一些的程序吗？毕竟，如果每个符号的值都是不能修改的，那么我们就什么东西都不能改变了！别紧张，这样的说法不完全正确。阿隆佐在设计lambda演算的时候他并不想要保留状态的值以便稍后修改这些值。他更关心的是基于数据之上的操作（也就是更容易理解的“计算”）。而且，lambda演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。那么，怎样才能做到呢？事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着写一个函数，用来反转一个Java的字符串。记住咯，这个程序里的变量都是默认为final的5。 12345678String reverse(String arg) &#123; if(arg.length == 0) &#123; return arg; &#125; else &#123; return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1); &#125;&#125; 这个方程运行起来会相对慢一些，因为它重复调用自己6。同时它也会大量的消耗内存，因为它会不断的分配创建内存对象。无论如何，它是用函数式编程思想写出来的。这时候可能有人要问了，为什么要用这种奇怪的方式编写程序呢？嘿，我正准备告诉你。 FP之优点你大概已经在想：上面这种怪胎函数怎么也不合理嘛。在我刚开始学习FP的时候我也这样想的。不过后来我知道我是错的。使用这种方式编程有很多好处。其中一些是主观的。比如说有人认为函数式程序更容易理解。这个我就不说了，哪怕街上随便找个小孩都知道‘容易理解’是多么主观的事情。幸运的是，客观方面的好处还有很多。 单元测试因为FP中的每个符号都是final的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。这正是单元测试工程师梦寐以求的啊。现在测试程序中的函数时只需要关注它的参数就可以了。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。唯一需要做的就是传递一些可以代表边界条件的参数给这些函数。相对于指令式编程，如果FP程序中的每一个函数都能通过单元测试，那么我们对这个软件的质量必将信心百倍。反观Java或者C++，仅仅检查函数的返回值是不够的：代码可能修改外部状态值，因此我们还需要验证这些外部的状态值的正确性。在FP语言中呢，就完全不需要。 调试查错如果一段FP程序没有按照预期设计那样运行，调试的工作几乎不费吹灰之力。这些错误是百分之一百可以重现的，因为FP程序中的错误不依赖于之前运行过的不相关的代码。而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。在FP中这种情况完全不存在：如果一个函数的返回值出错了，它一直都会出错，无论你之前运行了什么代码。一旦问题可以重现，解决它就变得非常简单，几乎就是一段愉悦的旅程。中断程序的运行，检查一下栈，就可以看到每一个函数调用时使用的每一个参数，这一点和指令式代码一样。不同的是指令式程序中这些数据还不足够，因为函数的运行还可能依赖于成员变量，全局变量，还有其他类的状态（而这些状态又依赖于类似的变量）。FP中的函数只依赖于传给它的参数，而这些参数就在眼前！还有，对指令式程序中函数返回值的检查并不能保证这个函数是正确运行的。还要逐一检查若干作用域以外的对象以确保这个函数没有对这些牵连的对象做出什么越轨的行为（译者：好吧，翻译到这里我自己已经有点激动了）。对于一个FP程序，你要做的仅仅是看一下函数的返回值。把栈上的数据过一遍就可以得知有哪些参数传给了什么函数，这些函数又返回了什么值。当一个返回值看起来不对头的那一刻，跳进这个函数看看里面发生了什么。一直重复跟进下去就可以找到bug的源头！ 并发执行不需要任何改动，所有FP程序都是可以并发执行的。由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。在FP程序中没有哪个线程可以修改任何数据，更不用说多线程之间了。这使得我们可以轻松的添加线程，至于那些祸害并发程序的老问题，想都不用想！既然是这样，为什么没有人在那些高度并行的那些应用程序中采用FP编程呢？事实上，这样的例子并不少见。爱立信开发了一种FP语言，名叫Erlang，并应用在他们的电信交换机上，而这些交换机不仅容错度高而且拓展性强。许多人看到了Erlang的这些优势也纷纷开始使用这一语言。在这里提到的电信交换控制系统远远要比华尔街上使用的系统具有更好的扩展性也更可靠。事实上，用Erlang搭建的系统并不具备可扩展性和可靠性，而Java可以提供这些特性。Erlang只是像岩石一样结实不容易出错而已。FP关于并行的优势不仅于此。就算某个FP程序本身只是单线程的，编译器也可以将其优化成可以在多CPU上运行的并发程序。以下面的程序为例： 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); 如果是函数式程序，编译器就可以对代码进行分析，然后可能分析出生成字符串s1和s2的两个函数可能会比较耗时，进而安排它们并行运行。这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。在函数式编程中，自动分析代码并找到适合并行执行的函数十分简单，和分析C的内联函数没什么两样。从这个角度来说用FP风格编写的程序是“永不过时”的（虽然我一般不喜欢说大话空话，不过这次就算个例外吧）。硬件厂商已经没办法让CPU运行得再快了。他们只能靠增加CPU核的数量然后用并行来提高运算的速度。这些厂商故意忽略一个事实：只有可以并行的软件才能让你花大价钱买来的这些硬件物有所值。指令式的软件中只有很小一部分能做到跨核运行，而所有的函数式软件都能实现这一目标，因为FP的程序从一开始就是可以并行运行的。 热部署在Windows早期，如果要更新系统那可是要重启电脑的，而且还要重启很多次。哪怕只是安装一个新版本的播放器。到了XP的时代这种情况得到比较大的改善，尽管还是不理想（我工作的时候用的就是Windows，就在现在，我的系统托盘上就有个讨厌的图标，我不重启机子就不消失）。这一方面Unix好一些，曾经。只需要暂停一些相关的部件而不是整个操作系统，就可以安装更新了。虽然是要好一些了，对很多服务器应用来说这也还是不能接受的。电信系统要求的是100%的在线率，如果一个救急电话因为系统升级而无法拨通，成千上万的人就会因此丧命。同样的，华尔街的那些公司怎么也不能说要安装软件而在整个周末停止他们系统的服务。最理想的情况是更新相关的代码而不用暂停系统的其他部件。对指令性程序来说是不可能的。想想看，试着在系统运行时卸载掉一个Java的类然后再载入这个类的新的实现，这样做的话系统中所有该类的实例都会立刻不能运行，因为该类的相关状态已经丢失了。这种情况下可能需绞尽脑汁设计复杂的版本控制代码，需要将所有这种类正在运行的实例序列化，逐一销毁它们，然后创建新类的实例，将现有数据也序列化后装载到这些新的实例中，最后希望负责装载的程序可以正确的把这些数据移植到新实例中并正常的工作。这种事很麻烦，每次有新的改动都需要手工编写装载程序来完成更新，而且这些装载程序还要很小心，以免破坏了现有对象之间的联系。理论上是没问题，可是实际上完全行不通。FP的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。其它的事情有FP的语言工具自动完成！如果还有人认为这只存在于科幻小说中，他需要再想想：多年来Erlang工程师已经使用这种技术对它们的系统进行升级而完全不用暂停运行了。 机器辅助优化及证明FP语言有一个特性很有意思，那就是它们是可以用数学方法来分析的。FP语言本身就是形式系统的实现，只要是能在纸上写出来的数学运算就可以用这种语言表述出来。于是只要能够用数学方法证明两段代码是一致的，编译器就可以把某段代码解析成在数学上等同的但效率又更高的另外一段代码7。 关系数据库已经用这种方法进行优化很多年了。没有理由在常规的软件行业就不能应用这种技术。另外，还可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来！对于那些对缺陷零容忍的系统来说，这一功能简直就是无价之宝。例如心脏起搏器，例如飞行管控系统，这几乎就是必须满足的需求。哪怕你正在开发的程序不是为了完成什么重要核心任务，这些工具也可以帮助你写出更健壮的程序，直接甩竞争对手n条大街。 高阶函数我还记得在了解到FP以上的各种好处后想到：“这些优势都很吸引人，可是，如果必须非要用这种所有变量都是final的蹩脚语言，估计还是不怎么实用吧”。其实这样的想法是不对的。对于Java这样的指令式语言来说，如果所有的变量都是必须是final的，那么确实很束手束脚。然而对函数式语言来说，情况就不一样了。函数式语言提供了一种特别的抽象工具，这种工具将帮助使用者编写FP代码，让他们甚至都没想到要修改变量的值。高阶函数就是这种工具之一。FP语言中的函数有别于Java或是C。可以说这种函数是一个全集：Java函数可以做到的它都能做，同时它还有更多的能力。首先，像在C里写程序那样创建一个函数： 123int add(int i, int j) &#123; return i + j;&#125; 看起来和C程序没什么区别，但是很快你就可以看出区别来。接下来我们扩展Java的编译器以便支持这种代码，也就是说，当我们写下以上的程序编译器会把它转化成下面的Java程序（别忘了，所有的变量都是final的）： 1234567class add_function_t &#123; int add(int i, int j) &#123; return i + j; &#125;&#125;add_function_t add = new add_function_t(); 在这里，符号add并不是一个函数，它是只有一个函数作为其成员的简单的类。这样做有很多好处，可以在程序中把add当成参数传给其他的函数，也可以把add赋给另外一个符号，还可以在运行时创建add_function_t的实例然后在不再需要这些实例的时候由系统回收机制处理掉。这样做使得函数成为和integer或是string这样的第一类对象。对其他函数进行操作（比如说把这些函数当成参数）的函数，就是所谓的高阶函数。别让这个看似高深的名字吓倒你（译者：好死不死起个这个名字，初一看还准备搬出已经尘封的高数教材……），它和Java中操作其他类（也就是把一个类实例传给另外的类）的类没有什么区别。可以称这样的类为“高阶类”，但是没人会在意，因为Java圈里就没有什么很强的学术社团。（译者：这是高级黑吗？）那么什么时候该用高阶函数，又怎样用呢？我很高兴有人问这个问题。设想一下，你写了一大堆程序而不考虑什么类结构设计，然后发现有一部分代码重复了几次，于是你就会把这部分代码独立出来作为一个函数以便多次调用（所幸学校里至少会教这个）。如果你发现这个函数里有一部分逻辑需要在不同的情况下实现不同的行为，那么你可以把这部分逻辑独立出来作为一个高阶函数。搞晕了？下面来看看我工作中的一个真实的例子。 假设有一段Java的客户端程序用来接收消息，用各种方式对消息做转换，然后发给一个服务器。 1234567891011class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode("ABCD_123"); // ... sendMessage(msg); &#125; // ...&#125; 再进一步假设，整个系统改变了，现在需要发给两个服务器而不再是一个了。系统其他部分都不变，唯独客户端的代码需要改变：额外的那个服务器需要用另外一种格式发送消息。应该如何处理这种情况呢？我们可以先检查一下消息要发送到哪里，然后选择相应的格式把这个消息发出去： 123456789101112131415class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... if(msg.getDestination().equals("server1") &#123; msg.setClientCode("ABCD_123"); &#125; else &#123; msg.setClientCode("123_ABC"); &#125; // ... sendMessage(msg); &#125; // ...&#125; 可是这样的实现是不具备扩展性的。如果将来需要增加更多的服务器，上面函数的大小将呈线性增长，使得维护这个函数最终变成一场噩梦。面向对象的编程方法告诉我们，可以把MessageHandler变成一个基类，然后将针对不同格式的消息编写相应的子类。 12345678910111213141516171819202122232425abstract class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode(getClientCode()); // ... sendMessage(msg); &#125; abstract String getClientCode(); // ...&#125;class MessageHandlerOne extends MessageHandler &#123; String getClientCode() &#123; return "ABCD_123"; &#125;&#125;class MessageHandlerTwo extends MessageHandler &#123; String getClientCode() &#123; return "123_ABCD"; &#125;&#125; 这样一来就可以为每一个接收消息的服务器生成一个相应的类对象，添加服务器就变得更加容易维护了。可是，这一个简单的改动引出了很多的代码。仅仅是为了支持不同的客户端行为代码，就要定义两种新的类型！现在来试试用我们刚才改造的语言来做同样的事情，注意，这种语言支持高阶函数： 12345678910111213141516171819202122class MessageHandler &#123; void handleMessage(Message msg, Function getClientCode) &#123; // ... Message msg1 = msg.setClientCode(getClientCode()); // ... sendMessage(msg1); &#125; // ...&#125;String getClientCodeOne() &#123; return "ABCD_123";&#125;String getClientCodeTwo() &#123; return "123_ABCD";&#125;MessageHandler handler = new MessageHandler();handler.handleMessage(someMsg, getClientCodeOne); 在上面的程序里，我们没有创建任何新的类型或是多层类的结构。仅仅是把相应的函数作为参数进行传递，就做到了和用面向对象编程一样的事情，而且还有额外的好处：一是不再受限于多层类的结构。这样做可以做运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。这种情况下编译器其实就是在替我们编写面向对象的“粘合”代码（译者：又称胶水代码，粘接代码）！除此之外我们还可以享用FP编程的其他所有优势。函数式编程能提供的抽象服务还远不止于此。高阶函数只不过是个开始。 Currying我遇见的大多数码农都读过“四人帮”的那本《设计模式》。任何稍有自尊心的码农都会说这本书和语言无关，因此无论你用什么编程语言，当中提到的那些模式大体上适用于所有软件工程。听起来很厉害，然而事实却不是这样。函数式语言的表达能力很强。用这种语言编程的时候基本不需要设计模式，因为这种语言层次已经足够高，使得使用者可以以概念编程，从而完全不需要设计模式了。以适配器模式为例（有人知道这个模式和外观模式有什么区别吗？怎么觉得有人为了出版合同的要求而硬生生凑页数？）（译者：您不愧是高级黑啊）。对于一个支持currying技术的语言来说，这个模式就是多余的。在Java中最有名的适配器模式就是在其“默认”抽象单元中的应用：类。在函数式语言中这种模式其实就是函数。在这个模式中，一个接口被转换成另外一个接口，让不同的用户代码调用。接下来就有一个适配器模式的例子： 12345int pow(int i, int j);int square(int i)&#123; return pow(i, 2);&#125; 上面的代码中square函数计算一个整数的平方，这个函数的接口被转换成计算一个整数的任意整数次幂。在学术圈里这种简单的技术就被叫做currying（因为逻辑学家哈斯凯尔·加里用其数学技巧将这种技术描述出来，于是就以他的名字来命名了）。在一个FP语言中函数（而不是类）被作为参数进行传递，currying常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是currying通常用于减少函数参数的数量（见前例）。函数式语言生来就支持这一技术，于是没有必要为某个函数手工创建另外一个函数去包装并转换它的接口，这些函数式语言已经为你做好了。我们继续拓展Java来支持这一功能。 1square = int pow(int i, 2); 上面的语句实现了一个平方计算函数，它只需要一个参数。它会继而调用pow函数并且把第二个参数置为2。编译过后将生成以下Java代码： 123456class square_function_t &#123; int square(int i) &#123; return pow(i, 2); &#125;&#125;square_function_t square = new square_function_t(); 从上面的例子可以看到，很简单的，函数pow的封装函数就创建出来了。在FP语言中currying就这么简单：一种可以快速且简单的实现函数封装的捷径。我们可以更专注于自己的设计，编译器则会为你编写正确的代码！什么时候使用currying呢？很简单，当你想要用适配器模式（或是封装函数）的时候，就是用currying的时候。 惰性求值惰性求值（或是延迟求值）是一种有趣的技术，而当我们投入函数式编程的怀抱后这种技术就有了得以实现的可能。前面介绍并发执行的时候已经提到过如下代码： 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); 在指令式语言中以上代码执行的顺序是显而易见的。由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。先是计算somewhatLongOperation1，然后到somewhatLongOperation2，最后执行concatenate。函数式语言就不一样了。在前面讨论过，somewhatLongOperation1和somewhatLongOperation2是可以并发执行的，因为函数式语言保证了一点：没有函数会影响或者依赖于全局状态。可是万一我们不想要这两个函数并发执行呢？这种情况下是不是也还是要顺序执行这些函数？答案是否定的。只有到了执行需要s1、s2作为参数的函数的时候，才真正需要执行这两个函数。于是在concatenate这个函数没有执行之前，都没有需要去执行这两个函数：这些函数的执行可以一直推迟到concatenate()中需要用到s1和s2的时候。假如把concatenate换成另外一个函数，这个函数中有条件判断语句而且实际上只会需要两个参数中的其中一个，那么就完全没有必要执行计算另外一个参数的函数了！Haskell语言就是一个支持惰性求值的例子。Haskell不能保证任何语句会顺序执行（甚至完全不会执行到），因为Haskell的代码只有在需要的时候才会被执行到。除了这些优点，惰性求值也有缺点。这里介绍了它的优点，我们将在下一章节介绍这些缺点以及如何克服它们。 代码优化惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。在此基础上优化是不会破坏代码正常运行的。严格使用形式系统的基本元素进行编程带来的最大的好处，是可以用数学方法分析处理代码，因为这样的程序是完全符合数学法则的。 抽象化控制结构惰性求值技术提供了更高阶的抽象能力，这提供了实现程序设计独特的方法。比如说下面的控制结构： 123unless(stock.isEuropean()) &#123; sendToSEC(stock);&#125; 程序中除了在stock为European的时候都会执行sendToSEC。如何实现例子中的unless？如果没有惰性求值就需要求助于某种形式的宏（译者：用if不行么？），不过在像Haskell这样的语言中就不需要那么麻烦了。直接实现一个unless函数就可以！ 1234void unless(boolean condition, List code) &#123; if(!condition) code;&#125; 请注意，如果condition值为真，那就不会计算code。在其他严格语言（见严格求值）中这种行为是做不到的，因为在进入unless这个函数之前，作为参数的code已经被计算过了。 无穷数据结构惰性求值技术允许定义无穷数据结构，这要在严格语言中实现将非常复杂。例如一个储存Fibonacci数列数字的列表。很明显这样一个列表是无法在有限的时间内计算出这个无穷的数列并存储在内存中的。在像Java这样的严格语言中，可以定义一个Fibonacci函数，返回这个序列中的某个数。而在Haskell或是类似的语言中，可以把这个函数进一步抽象化并定义一个Fibonacci数列的无穷列表结构。由于语言本身支持惰性求值，这个列表中只有真正会被用到的数才会被计算出来。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们（比如可以在一个列表处理函数中处理无穷多数据的列表）。 不足之处俗话说天下没有免费的午餐™。惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实世界中很多问题还是需要严格求值的。比如说下面的例子： 12System.out.println("Please enter your name: ");System.in.readLine(); 在惰性语言中没人能保证第一行会中第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何有用的事情（这些函数需要按照顺序执行，因为它们依赖于外部状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。幸运的是我们还不算一无所有。数学家们研究了不同的方法用以保证代码按一定的顺序执行（in a functional setting?）。这一来我们就可以同时利用到函数式和指令式编程的优点了！这些方法有continuations，monads以及uniqueness typing。这篇文章仅仅介绍了continuations，以后再讨论monads和uniqueness typing。有意思的是呢，coutinuations处理强制代码以特定顺序执行之外还有其他很多用处，这些我们在后面也会提及。 Continuationcontinuation对于编程，就像是达芬奇密码对于人类历史一样：它揭开了人类有史以来最大的谜团。好吧，也许没有那么夸张，不过它们的影响至少和当年发现负数有平方根不相上下。 我们对函数的理解只有一半是正确的，因为这样的理解基于一个错误的假设：函数一定要把其返回值返回给调用者。按照这样的理解，continuation就是更加广义的函数。这里的函数不一定要把返回值传回给调用者，相反，它可以把返回值传给程序中的任意代码。continuation就是一种特别的参数，把这种参数传到函数中，函数就能够根据continuation将返回值传递到程序中的某段代码中。说得很高深，实际上没那么复杂。直接来看看下面的例子好了： 12int i = add(5, 10);int j = square(i); add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。请注意支持惰性求值的编译器是不能打乱这段代码执行顺序的，因为第二个函数的执行依赖于第一个函数成功执行并返回结果。这段代码可以用Continuation Pass Style（CPS）技术重写，这样一来add的返回值就不是传给其调用者，而是直接传到square里去了。 1int j = add(5, 10, square); 在上例中，add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。这时square就是add的一个continuation。上面两段程序中j的值都是225。 这样，我们学习到了强制惰性语言顺序执行两个表达式的第一个技巧。再来看看下面IO程序（是不是有点眼熟？）： 12System.out.println("Please enter your name: ");System.in.readLine(); 这两行代码彼此之间没有依赖关系，因此编译器可以随意的重新安排它们的执行顺序。可是只要用CPS重写它，编译器就必须顺序执行了，因为重写后的代码存在依赖关系了。 1System.out.println("Please enter your name: ", System.in.readLine); 这段新的代码中println需要结合其计算结果调用readLine，然后再返回readLine的返回值。这使得两个函数得以保证按顺序执行而且readLine总被执行（这是由于整个运算需要它的返回值作为最终结果）。Java的println是没有返回值的，但是如果它可以返回一个能被readLine接受的抽象值，问题就解决了！（译者：别忘了，这里作者一开始就在Java的基础上修改搭建自己的语言）当然，如果一直把函数按照这种方法串下去，代码很快就变得不可读了，可是没有人要求你一定要这样做。可以通过在语言中添加语法糖的方式来解决这个问题，这样程序员只要按照顺序写代码，编译器负责自动把它们串起来就好了。于是就可以任意安排代码的执行顺序而不用担心会失去FP带来的好处了（包括可以用数学方法来分析我们的程序）！如果到这里还有人感到困惑，可以这样理解，函数只是有唯一成员的类的实例而已。试着重写上面两行程序，让println和readLine变成这种类的实例，所有问题就都搞清楚了。到这里本章基本可以结束了，而我们仅仅了解到continuation的一点皮毛，对它的用途也知之甚少。我们可以用CPS完成整个程序，程序里所有的函数都有一个额外的continuation作为参数接受其他函数的返回值。还可以把任何程序转换为CPS的，需要做的只是把当中的函数看作是特殊的continuation（总是将返回值传给调用者的continuation）就可以了，简单到完全可以由工具自动完成（史上很多编译器就是这样做的）。 一旦将程序转为CPS的风格，有些事情就变得显而易见了：每一条指令都会有一些continuation，都会将它的计算结果传给某一个函数并调用它，在一个普通的程序中这个函数就是该指令被调用并且返回的地方。随便找个之前提到过的代码，比如说add(5,10)好了。如果add属于一个用CPS风格写出的程序，add的continuation很明显就是当它执行结束后要调用的那个函数。可是在一个非CPS的程序中，add的continuation又是什么呢？当然我们还是可以把这段程序转成CPS的，可是有必要这样做吗？事实上没有必要。注意观察整个CPS转换过程，如果有人尝试要为CPS程序写编译器并且认真思考过就会发现：CPS的程序是不需要栈的！在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。于是就不需要在每次调用函数的时候把参数压栈再将它们从中取出，只要把这些参数存放在一片内存中然后使用跳转指令就解决问题了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！简单点说呢，用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。非CPS风格的程序不需要额外的参数但又需要栈才能运行。栈里面存的是什么？仅仅是参数还有一个供函数运行结束后返回的程序指针而已。这个时候你是不是已经恍然大悟了？对啊，栈里面的数据实际上就是continuation的信息！栈上的程序返回指针实质上就是CPS程序中需要调用的下一个函数！想要知道add(5, 10)的continuation是什么？只要看它运行时栈的内容就可以了。接下来就简单多了。continuation和栈上指示函数返回地址的指针其实是同一样东西，只是continuation是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。前面说过，continuation就是函数，而在我们特制的语言中函数就是类的实例，那么可以得知栈上指向函数返回地址的指针和continuation的参数是一样的，因为我们所谓的函数（就像类的一个实例）其实就是指针。这也意味着在程序运行的任何时候，你都可以得到当前的continuation（就是栈上的信息）。 好了，我们已经搞清楚当前的continuation是什么了。接下来要弄明白它的存在有什么意义。只要得到了当前的continuation并将它保存起来，就相当于保存了程序的当前状态：在时间轴上把它冻结起来了。这有点像操作系统进入休眠状态。continuation对象保存了足够的信息随时可以从指定的某个状态继续运行程序。在切换线程的时候操作系统也是这样做的。唯一的区别在于它保留了所有的控制权利。当请求某个continuation对象时（在Scheme语言中是通过调用call-with-current-continuation函数实现的）得到的是一个存有当前continuation的对象，也就是栈对象（在CPS中也就是下一个要执行的函数）。可以把这个对象保存做一个变量中（或者是存在磁盘上）。当以该continuation对象“重启”该程序时，程序的状态就会立即“转换”为该对象中保存的状态。这一点和切换回一个被暂停的线程或是从系统休眠中唤醒很相像，唯一不同的是continuatoin对象可以反复的这样使用。当系统唤醒后，休眠前保存的信息就会销毁，否则你也可以反复的从该点唤醒系统，就像乘时光机回到过去一样。有了continuation你就可以做到这一点！ 那么continuation在什么情况下有用呢？有一些应用程序天生就没有状态，如果要在这样的系统中模拟出状态以简化工作的时候，就可以用到continuation。最合适的应用场合之一就是网页应用程序。微软的ASP.NET为了让程序员更轻松的编写应用程序，花了大量的精力去模拟各种状态。假如C#支持continuation的话，那么ASP.NET的复杂度将减半：因为只要把某一时刻的continuation保存起来，下次用户再次发起同样请求的时候，重新载入这个continuation即可。对于网络应用的程序员来说就再也没有中断了：轻轻松松程序就从下一行开始继续运行了！对于一些实际问题来说，continuation是一种非常有用的抽象工具。如今大量的传统胖客户端（见瘦客户端）正纷纷走进网络，continuation在未来将扮演越来越重要的角色。 模式匹配模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。它之所以常常被认为是FP的一个特性，是因为在函数式语言已经支持模式匹配很长一段时间后的今天，指令式语言是还没有这个功能。 还是直接用例子来看看什么是模式匹配吧，这是一个用Java写的Fibonacci函数： 123456int fib(int n) &#123; if(n == 0) return 1; if(n == 1) return 1; return fib(n - 2) + fib(n - 1);&#125; 再看看用我们基于Java修改过的新语言写出来的Fibonacci函数，这种新语言就支持模式匹配： 123456789int fib(0) &#123; return 1;&#125;int fib(1) &#123; return 1;&#125;int fib(int n) &#123; return fib(n - 2) + fib(n - 1);&#125; 区别在哪里呢？在于后者的编译器替我们实现了程序的分支。这有什么了不起的？确实也没什么。只是有人注意到很多函数中有非常复杂的switch结构（对于函数式程序而言更是如此），于是想到如果能把这层结构也抽象化就更好了。然后就把这个复杂的函数拆分成若干新的函数，并在这些函数的某些参数中应用模式（这和重载有点类似）。这样依赖当这个函数被调用的时候，编译器会在运行时将调用者传入的参数与各个新函数的参数定义进行比较，找出合适的那个函数来执行。合适的函数往往是参数定义上最具体最接近传入参数的那个函数。在这个例子中，当n为1时，可以用函数int fib(int n)，不过真正调用的是int fib(1)因为这个函数更具体更接近调用者的要求。模式匹配一般来说要比这里举的例子更加复杂。比如说，高级模式匹配系统可以支持下面的操作： 12int f(int n &lt; 10) &#123; ... &#125;int f(int n) &#123; ... &#125; 那么什么情况下模式匹配会有用呢？在需要处理一大堆程序分支的时候！每当需要实现复杂的嵌套if语句的时候，模式匹配可以帮助你用更少的代码更好的完成任务。我所知道的一个这样的函数是标准的WndProc函数，该函数是所有Win32应用程序必须具备的（尽管它经常会被抽象化）。模式匹配系统一般都可以像匹配简单数值一样匹配数据集合。举个例子，对于一个接受数组作为参数的函数，可以通过模式匹配数组中第一个数字为1并且第三个数字大于3的输入。模式匹配的另外一个好处是每当需要添加或者修改程序分支时，再也不用面对那个庞大臃肿的函数了。只要添加（或者修改）相关的函数定义即可。有了模式匹配就不再需要四人帮的很多设计模式了。程序分支越多越复杂，模式匹配就越有用。而在习惯使用这一技术之后，你可能会怀疑没有它你一天都过不下去了。 Closure目前为止关于函数式编程各种功能的讨论都只局限在“纯”函数式语言范围内：这些语言都是lambda演算的实现并且都没有那些和阿隆佐形式系统相冲突的特性。然而，很多函数式语言的特性哪怕是在lambda演算框架之外都是很有用的。确实，如果一个公理系统的实现可以用数学思维来看待程序，那么这个实现还是很有用的，但这样的实现却不一定可以付诸实践。很多现实中的语言都选择吸收函数式编程的一些元素，却又不完全受限于函数式教条的束缚。很多这样的语言（比如Common Lisp）都不要求所有的变量必须为final，可以修改他们的值。也不要求函数只能依赖于它们的参数，而是可以读写函数外部的状态。同时这些语言又包含了FP的特性，如高阶函数。与在lambda演算限制下将函数作为参数传递不同，在指令式语言中要做到同样的事情需要支持一个有趣的特性，人们常把它称为lexical closure。还是来看看例子。要注意的是，这个例子中变量不是final，而且函数也可以读写其外部的变量： 12345678910Function makePowerFn(int power) &#123; int powerFn(int base) &#123; return pow(base, power); &#125; return powerFn;&#125;Function square = makePowerFn(2);square(3); // returns 9 makePowerFn函数返回另一个函数，这个新的函数需要一个整数参数然后返回它的平方值。执行square(3)的时候具体发生了什么事呢？变量power并不在powerFn的域内，因为makePowerFn早就运行结束返回了，所以它的栈也已经不存在了。那么square又是怎么正常工作的呢？这个时候需要语言通过某种方式支持继续存储power的值，以便square后面继续使用。那么如果再定义一个函数，cube，用来计算立方，又应该怎么做呢？那么运行中的程序就必须存储两份power的值，提供给makePowerFn生成的两个函数分别使用。这种保存变量值的方法就叫做closure。closure不仅仅保存宿主函数的参数值，还可以用在下例的用法中： 1234567891011121314151617Function makeIncrementer() &#123; int n = 0; int increment() &#123; return ++n; &#125;&#125;Function inc1 = makeIncrementer();Function inc2 = makeIncrementer();inc1(); // returns 1;inc1(); // returns 2;inc1(); // returns 3;inc2(); // returns 1;inc2(); // returns 2;inc2(); // returns 3; 运行中的程序负责存储n的值，以便incrementer稍后可以访问它。与此同时，程序还会保存多份n的拷贝，虽然这些值应该在makeIncrementer返回后就消失，但在这个情况下却继续保留下来给每一个incrementer对象使用。这样的代码编译之后会是什么样子？closure幕后的真正工作机理又是什么？这次运气不错，我们有一个后台通行证，可以一窥究竟。一点小常识往往可以帮大忙。乍一看这些本地变量已经不再受限于基本的域限制并拥有无限的生命周期了。于是可以得出一个很明显的结论：它们已经不是存在栈上，而是堆上了8。这么说来closure的实现和前面讨论过的函数差不多，只不过closure多了一个额外的引用指向其外部的变量而已： 12345class some_function_t &#123; SymbolTable parentScope; // ...&#125; 当closure需要访问不在它本地域的变量时，就可以通过这个引用到更外一层的父域中寻找该变量。谜底揭开了！closure将函数编程与面向对象的方法结合了起来。下一次为了保存并传递某些状态而创建类的时候，想想closure。它能在运行时从相应的域中获得变量，从而可以把该变量当成“成员变量”来访问，也因为这样，就不再需要去创建一个成员变量了。 路在何方？这篇文章仅仅涉及到函数式编程的一些皮毛。考虑到有时候星星之火可以燎原，所以如果它能给你一些帮助那就再好不过了。接下来我计划就范畴论、monads、函数式编程数据结构、函数式语言中的类型系统、并行函数式编程、数据库的函数式编程以及更多的话题写些类似的文章。如果我可以写出（在我学习的同时）以上清单的一半，我的人生就完整了。于此同时，Google将是我们的良师益友。 欢迎联系如果您有任何问题，评价或者建议，请发邮件到coffeemug@gmail.com（译者：如果翻译方面的问题／建议请发到yang.huang@ymail.com:)）。期待您的回复。 注：1当我在2005年求职时的的确确经常问别人这个问题。看着那些茫然的面孔实在是很好玩的事情。你们这些年薪30万美金的家伙，至少应该对自己可以利用的工具有个起码的理解嘛。2这是个有争议的问题。物理学家和数学家不得不承认目前还无法确定宇宙万物是不是都遵从可以用数学方法描述的各种法则。3我一直一来都很讨厌在历史课上罗列一堆枯燥无味的时间、人名、事件。对我来说历史就是关于那些改变世界的人们活生生的故事，是他们行为背后的个人动机，是那些他们用以影响芸芸众生的方法和工具。从这个角度来说，接下来的这堂历史课是不完整的，很遗憾。只有那些非常相关的人和事会被提及。4在我学习函数式编程的时候，“lambda”这个术语搞得我很烦，因为我不知道它到底是什么意思。在这里lambda就是一个函数，在数学符号中用这个希腊字母只是因为它更容易写。所以以后在谈及函数式编程的时候只要你听到lambda，把它在脑中翻译为“函数”就可以了。5有意思的是不论如何Java中的字符串总是不可修改的。讨论这种背叛Java的设计背后的原因会很有意思，可惜这样会让我们跑题的。6大部分函数式语言的编译器都会尽量将迭代函数转换为对等的循环语句。这种做法叫做尾调用优化。7反之则不一定成立。尽管有时候可以证明两段代码是等价的，但不是在所有的情况下都可以得出这样的结论。8实际上这样做并不比栈上存储要慢，因为在引入垃圾回收机制)后，内存分配操作的时间代价仅为O(1)。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>原文</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL脚本编程_2]]></title>
    <url>%2F2018%2F11%2F25%2FSHELL%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B_2%2F</url>
    <content type="text"><![CDATA[给出的那些shell脚本里, shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说,这已经足够了,因为在这种操作环境下,你想要的就是所有的命令按照正确的顺序执行。然而,并非所有程序都如此操作。许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令(structured command)。 使用结构化命令 使用if -then语句最基本的结构化命令就是 if-then 语句。 if-then 语句有如下格式。1234if commandthen commandsfi bash shell的 if 语句会运行 if 后面的那个命令。如果该命令的退出状态码是 0(该命令成功运行),位于 then 部分的命令就会被执行。如果该命令的退出状态码是其他值, then部分的命令就不会被执行,bash shell会继续执行脚本中的下一个命令。 fi 语句用来表示 if-then语句到此结束。 有些脚本中看到过 if-then 语句的另一种形式: 123if command; then commandsfi 通过把分号放在待求值的命令尾部,就可以将 then 语句放在同一行上了,这样看起来更像其他编程语言中的 if-then 语句。在 then 部分,你可以使用不止一条命令。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell会将这些命令当成一个块,如果 if 语句行的命令的退出状态值为 0 ,所有的命令都会被执行;如果 if 语句行的命令的退出状态不为 0 ,所有的命令都会被跳过。 if-then-else 语句在 if-then 语句中,不管命令是否成功执行,你都只有一种选择。如果命令返回一个非零退出状态码,bash shell会继续执行脚本中的下一条命令。在这种情况下,如果能够执行另一组命令就好了。这正是 if-then-else 语句的作用。if-then-else 语句在语句中提供了另外一组命令。123456if commandthen commandselse commandsfi 当 if 语句中的命令返回退出状态码 0 时, then 部分中的命令会被执行,这跟普通的 if-then语句一样。当 if 语句中的命令返回非零退出状态码时,bash shell会执行 else 部分中的命令。 嵌套if可以直接嵌套if结构，理论上支持多重嵌套，实际上程序员并不会放置超过三重，过多影响代码的逻辑性和可读性。可以使用 else 部分的另一种形式: elif 。这样就不用再书写多个 if-then 语句了。 elif 使用另一个 if-then 语句延续 else 部分。1234567if command1then commandselif command2then more commandsfi 在 elif 语句中,紧跟其后的 else 语句属于 elif 代码块。它们并不属于之前的if-then 代码块。可以继续将多个 elif 语句串起来,形成一个大的 if-then-elif 嵌套组合。12345678910111213if command1then command set 1elif command2then command set 2elif command3then command set 3elif command4then command set 4fi test 命令test 命令提供了在 if-then 语句中测试不同条件的途径。如果 test 命令中列出的条件成立,test 命令就会退出并返回退出状态码 0 。这样 if-then 语句就与其他编程语言中的 if-then 语句以类似的方式工作了。如果条件不成立, test 命令就会退出并返回非零的退出状态码,这使得if-then 语句不会再被执行。test 命令的格式非常简单。1test condition condition 是 test 命令要测试的一系列参数和值。当用在 if-then 语句中时, test 命令看起来是这样的。1234if test conditionthen commandsfi 如果不写 test 命令的 condition 部分,它会以非零的退出状态码退出,并执行 else 语句块。bash shell提供了另一种条件测试方法,无需在 if-then 语句中声明 test 命令。1234if [ condition ]then commandsfi 方括号定义了测试条件。注意,第一个方括号之后和第二个方括号之前必须加上一个空格,否则就会报错。test 命令可以判断三类条件: 数值比较 字符串比较 文件比较 数值比较使用 test 命令最常见的情形是对两个数值进行比较。下表列出了测试两个值时可用的条件参数。 比较 描述 n1 -eq n2 检查 n1 是否与 n2 相等 n1 -ge n2 检查 n1 是否大于或等于 n2 n1 -gt n2 检查 n1 是否大于 n2 n1 -le n2 检查 n1 是否小于或等于 n2 n1 -lt n2 检查 n1 是否小于 n2 n1 -ne n2 检查 n1 是否不等于 n2 字符串比较条件测试还允许比较字符串值。比较字符串比较烦琐,你马上就会看到。下表列出了可用的字符串比较功能。 比较 描述 str1 = str2 检查 str1 是否和 str2 相同 str1 != str2 检查 str1 是否和 str2 不同 str1 &lt; str2 检查 str1 是否比 str2 小 str1 &gt; str2 检查 str1 是否比 str2 大 -n str1 检查 str1 的长度是否非0 -z str1 检查 str1 的长度是否为0 字符串相等性字符串的相等和不等条件不言自明,很容易看出两个字符串值是否相同，字符串不等条件也可以判断两个字符串是否有相同的值。记住,在比较字符串的相等性时,比较测试会将所有的标点和大小写情况都考虑在内。 字符串顺序要测试一个字符串是否比另一个字符串大就是麻烦的开始。当要开始使用测试条件的大于或小于功能时,就会出现两个经常困扰shell程序员的问题: 大于号和小于号必须转义,否则shell会把它们当作重定向符号,把字符串值当作文件名 大于和小于顺序和 sort 命令所采用的不同在编写脚本时,第一条可能会导致一个不易察觉的严重问题。 test 命令和测试表达式使用标准的数学比较符号来表示字符串比较,而用文本代码来表示数值比较。这个细微的特性被很多程序员理解反了。如果你对数值使用了数学运算符号,shell会将它们当成字符串值,可能无法得到正确的结果。 检查字符串大小-n 和 -z 可以检查一个变量是否含有数据。空的和未初始化的变量会对shell脚本测试造成灾难性的影响。如果不是很确定一个变量的内容,最好在将其用于数值或字符串比较之前先通过 -n 或 -z 来测试一下变量是否含有值。 文件比较最后一类比较测试很有可能是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。下表列出了这些比较。 比较 描述 -d file 检查 file 是否存在并是一个目录 -e file 检查 file 是否存在 -f file 检查 file 是否存在并是一个文件 -r file 检查 file 是否存在并可读 -s file 检查 file 是否存在并非空 -w file 检查 file 是否存在并可写 -x file 检查 file 是否存在并可执行 -O file 检查 file 是否存在并属当前用户所有 -G file 检查 file 是否存在并且默认组与当前用户相同 file1 -nt file2 检查 file1 是否比 file2 新 file1 -ot file2 检查 file1 是否比 file2 旧 检查目录-d 测试会检查指定的目录是否存在于系统中。如果你打算将文件写入目录或是准备切换到某个目录中,先进行测试总是件好事情。 检查对象是否存在-e 比较允许你的脚本代码在使用文件或目录前先检查它们是否存在。 检查文件-e 比较可用于文件和目录。要确定指定对象为文件,必须用 -f 比较。 检查是否可读在尝试从文件中读取数据之前,最好先测试一下文件是否可读。可以使用 -r 比较测试。 检查空文件应该用 -s 比较来检查文件是否为空,尤其是在不想删除非空文件的时候。要留心的是,当-s 比较成功时,说明文件中有数据。 检查是否可写-w 比较会判断你对文件是否有可写权限。 检查文件是否可以执行-x 比较是判断特定文件是否有执行权限的一个简单方法。虽然可能大多数命令用不到它,但如果你要在shell脚本中运行大量脚本,它就能发挥作用。 检查所属关系-O 比较可以测试出你是否是文件的属主。 检查默认属组关系-G 比较会检查文件的默认组,如果它匹配了用户的默认组,则测试成功。由于 -G 比较只会检查默认组而非用户所属的所有组。 检查文件日期最后一组方法用来对两个文件的创建日期进行比较。这在编写软件安装脚本时非常有用。有时候,你不会愿意安装一个比系统上已有文件还要旧的文件。 -nt 比较会判定一个文件是否比另一个文件新。如果文件较新,那意味着它的文件创建日期更近。 -ot 比较会判定一个文件是否比另一个文件旧。如果文件较旧,意味着它的创建日期更早。 复合条件测试if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用: [ condition1 ] &amp;&amp; [ condition2 ] [ condition1 ] || [ condition2 ] 第一种布尔运算使用 AND 布尔运算符来组合两个条件。要让 then 部分的命令执行,两个条件都必须满足。!布尔逻辑是一种能够将可能的返回值简化为 TRUE 或 FALSE 的方法。 第二种布尔运算使用 OR 布尔运算符来组合两个条件。如果任意条件为 TRUE , then 部分的命令就会执行。 if-then 的高级特性bash shell提供了两项可在 if-then 语句中使用的高级特性: 用于数学表达式的双括号 用于高级字符串处理功能的双方括号 使用双括号 13双括号命令允许你在比较过程中使用高级数学表达式。 test 命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号,这些符号对于用过其他编程语言的程序员而言并不陌生。双括号命令的格式如下:(( expression ))expression 可以是任意的数学赋值或比较表达式。除了 test 命令使用的标准数学运算符,下表列出了双括号命令中会用到的其他运算符。 符号 描述 val++ 后增 val– 后减 ++val 先增 –val 先减 ! 逻辑求反 ~ 位求反 ** 幂运算 &lt;&lt; 左位移 &gt;&gt; 右位移 &amp; 位布尔和 ｜ 位布尔或 &amp;&amp; 逻辑和 ｜｜ 逻辑或 可以在 if 语句中用双括号命令,也可以在脚本中的普通命令里使用来赋值。注意,不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。 使用双方括号双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下:[[ expression ]]双方括号里的 expression 使用了 test 命令中采用的标准字符串比较。但它提供了 test 命令未提供的另一个特性——模式匹配(pattern matching)。在模式匹配中,可以定义一个正则表达式来匹配字符串值。 case 命令有了 case 命令,就不需要再写出所有的 elif 语句来不停地检查同一个变量的值了。 case 命令会采用列表格式来检查单个变量的多个值。12345case variable inpattern1 | pattern2) commands1;;pattern3) commands2;;*) default commands;;esac case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的,那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。case 命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项。 可能是心情好，今晚突然想写博客，就更新了这篇。我和我女友和好了，真的很开心，希望不会再分开了吧]]></content>
      <categories>
        <category>SHELL</category>
        <category>学习</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>SHELL</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL脚本编程_1]]></title>
    <url>%2F2018%2F11%2F25%2FSHELL%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B_1%2F</url>
    <content type="text"><![CDATA[我已经了解了如何使用shell的命令行界面提示符来输入命令和查看命令的结果。shell脚本的优点在于输入多个命令并处理每个命令的结果,甚至需要将一个命令的结果传给另一个命令。shell可以让我将多个命令串起来,一次执行完成。 构建基本脚本创建 shell 脚本文件创建shell脚本文件时,必须在文件的第一行指定要使用的shell。其格式为:#!/bin/bash处第一行外，通常的shell脚本中,井号( # )用作注释行。 显示消息在 echo 命令后面加上了一个字符串,该命令就能显示出这个文本字符串。 123$ echo This is a testThis is a test$ echo 命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们,你需要在文本中使用其中一种引号,而用另外一种来将字符串划定起来。 如果想把文本字符串和命令输出显示在同一行中,可以用 echo 语句的 -n 参数。123echo -n &quot;The time and date are: &quot;$ ./test1The time and date are: Mon Feb 21 15:42:23 EST 2014 使用变量环境变量shell维护着一组环境变量,用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户的默认主目录以及shell查找程序的搜索路径。可以用set 命令来显示一份完整的当前环境变量列表。在脚本中,你可以在环境变量名称之前加上美元符( $ )来使用这些环境变量。（你可能还见过通过${variable} 形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名。） 用户变量用户变量可以是任何由字母、数字或下划线组成的文本字符串,长度不超过20个。用户变量区分大小写,所以变量 Var1 和变量 var1 是不同的。使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格(另一个困扰初学者的用法)。举例：1234var1=10var2=-57var3=testingvar4=&quot;still more testing&quot; shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里,shell脚本中定义的变量会一直保持着它们的值,但在shell脚本结束时会被删除掉。与系统变量类似,用户变量可通过美元符引用。12345678910$ cat test3#!/bin/bash# testing variablesdays=10guest=&quot;Katie&quot;echo &quot;$guest checked in $days days ago&quot;days=5guest=&quot;Jessica&quot;echo &quot;$guest checked in $days days ago&quot;$ 运行脚本会有如下输出。12345$ chmod u+x test3$ ./test3Katie checked in 10 days agoJessica checked in 5 days ago$ 变量每次被引用时,都会输出当前赋给它的值。重要的是要记住,引用一个变量值时需要使用美元符,而引用变量来对其进行赋值时则不要使用美元符。 命令替换shell脚本中最有用的特性之一就是可以从命令输出中提取信息,并将其赋给变量。把输出赋给变量之后,就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。 反引号字符( ` ) $() 格式 12testing=&apos;date&apos;testing=$(date) 这个例子毫无吸引人的地方(也可以干脆将该命令放在 echo 语句中),但只要将命令的输出放到了变量里,你就可以想干什么就干什么了。 命令替换会创建一个子shell来运行对应的命令。子shell ( subshell)是由运行该脚本的shell所创建出来的一个独立的子shell(child shell)。正因如此,由该子shell所执行命令是无法使用脚本中所创建的变量的。在命令行提示符下使用路径 ./ 运行命令的话,也会创建出子shell;要是运行命令的时候不加入路径,就不会创建子shell。如果你使用的是内建的shell命令,并不会涉及子shell。在命令行提示符下运行脚本时一定要留心! 数学运算有了变量，有了数值就可以进行数学运算了。 expr 命令expr 命令允许在命令行上处理数学表达式,但是特别笨拙。12$ expr 1 + 56 操作符 描述 ARG1 ｜ ARG2 如果 ARG1 既不是null也不是零值,返回 ARG1 ;否则返回 ARG2 ARG1 &amp; ARG2 如果没有参数是null或零值,返回 ARG1 ;否则返回 0 ARG1 &lt; ARG2 如果 ARG1 小于 ARG2 ,返回 1 ;否则返回 0 ARG1 &lt;= ARG2 如果 ARG1 小于或等于 ARG2 ,返回 1 ;否则返回 0 ARG1 = ARG2 如果 ARG1 等于 ARG2 ,返回 1 ;否则返回 0 ARG1 != ARG2 如果 ARG1 不等于 ARG2 ,返回 1 ;否则返回 0 ARG1 &gt;= ARG2 如果 ARG1 大于或等于 ARG2 ,返回 1 ;否则返回 0 ARG1 &gt; ARG2 如果 ARG1 大于 ARG2 ,返回 1 ;否则返回 0 ARG1 + ARG2 返回 ARG1 和 ARG2 的算术运算和 ARG1 - ARG2 返回 ARG1 和 ARG2 的算术运算差 ARG1 * ARG2 返回 ARG1 和 ARG2 的算术乘积 ARG1 / ARG2 返回 ARG1 被 ARG2 除的算术商 ARG1 % ARG2 返回 ARG1 被 ARG2 除的算术余数 STRING : REGEXP 如果 REGEXP 匹配到了 STRING 中的某个模式,返回该模式匹配 match STRING REGEXP 如果 REGEXP 匹配到了 STRING 中的某个模式,返回该模式匹配 substr STRING POS LENGTH 返回起始位置为 POS (从 1 开始计数)、长度为 LENGTH 个字符的子字符串 index STRING CHARS 返回在 STRING 中找到 CHARS 字符串的位置;否则,返回 0 length STRING 返回字符串 STRING 的数值长度 + TOKEN 将 TOKEN 解释成字符串,即使是个关键字 (EXPRESSION) 返回 EXPRESSION 的值 对于那些容易被shell错误解释的字符,在它们传入 expr 命令之前,需要使用shell的转义字符(反斜线)将其标出来。比如 * 使用方括号在bash中,在将一个数学运算结果赋给某个变量时,可以用美元符和方括号( $[ operation ] )将数学表达式围起来。1234567$ var1=$[1 + 5]$ echo $var16$ var2=$[$var1 * 2]$ echo $var212$ bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算,这是一个巨大的限制。 浮点数解决方案－bc计算机bash计算器实际上是一种编程语言,它允许在命令行中输入浮点表达式,然后解释并计算该表达式,最后返回结果。bash计算器能够识别: 数字(整数和浮点数) 变量(简单变量和数组) 注释(以#或C语言中的 / \/ 开始的行) 表达式 编程语句(例如 if-then 语句) 函数 1234567891011$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type &apos;warranty&apos;.12 * 5.464.83.156 * (3 + 5)25.248quit$ 要退出bash计算器,你必须输入 quit 。浮点运算是由内建变量 scale 控制的。必须将这个值设置为你希望在计算结果中保留的小数位数,否则无法得到期望的结果。-q 命令行选项可以不显示bash计算器冗长的欢迎信息。12345678$ bc -q3.44 / 50scale=43.44 / 5.6880quit$ 现在你可能想问bash计算器是如何在shell脚本中帮助处理浮点运算的。还记得命令替换吗?是的,可以用命令替换运行 bc 命令,并将输出赋给一个变量。基本格式如下:variable=$(echo &quot;options; expression&quot; | bc)举例：12345$ cat test9#!/bin/bashvar1=$(echo &quot;scale=4; 3.44 / 5&quot; | bc)echo The answer is $var1$ 行了吧，我实在写不下去，前两天和我喜欢的女孩子分手了。这两天状态一直不好。我还爱她啊，只是异地恋太辛苦，实在没有坚持下去的勇气，愿上天让她幸福]]></content>
      <categories>
        <category>学习</category>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>SHELL</tag>
        <tag>编程</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL 提示符学习汇总]]></title>
    <url>%2F2018%2F11%2F25%2FSHELL%E6%8F%90%E7%A4%BA%E7%AC%A6%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB_%EF%BC%91%2F</url>
    <content type="text"><![CDATA[学习Linux，怎么能不会命令行呢？本文是对Linux命令行的学习过程记录。 简单命令 date显示当前时间和日期。 df 查看磁盘使用情况。 exit结束终端会话。 pwd打印出当前工作目录名。 cd更改目录。 ls列出目录内容。 以.字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们，用 ls -a命令就可以了。 file 确定文件类型。 less浏览文件内容。按下 q 按键退出 file filename打印出文件内容的简单描述。 cd快捷键 cd更改工作目录到你的家目录。 cd-跟改工作目录到先前的工作目录。 cd ̃user name更改工作目录到用户家目录。 符号.指的是工作目录，..指的是工作目录的父目录。 ls快捷指令 -a --all 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 -d --directory 通常，如果指定了目录名，ls 命令会列出这个目录中的内容,而不是目录本身。把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 -F -classify 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个’/’ 字符。 -h --human-readable 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 -l 以长格式显示结果。 -r --reverse 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 -S 命令输出结果按照文件大小来排序。 -t 按照修改时间来排序。 操作文件和目录 cp 复制文件和目录 mv 移动/重命名文件和目录 mkdir 创建目录 rm 删除文件和目录 ln 创建硬链接和符号链接 通配符 *匹配任意多个字符（包括零个或一个） ? 匹配任意一个字符（不包括零个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不是字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 [:alnum:] 匹配任意一个字母或数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper] 匹配任意一个大写字母 cp的应用 -a, --archive 复制文件和目录，以及它们的属性，包括所有权和权限。通常，复本具有用户所操作文件的默认属性。 -i, --interactive 在重写已存在文件之前，提示用户确认。如果这个选项不指定，cp 命令会默认重写文件。 -r, --recursive 递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者 -a 选项）。 -u, --update 当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 -v, --verbose 显示翔实的命令操作信息。 mv应用举例 -i --interactive 在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。 -u --update 当把文件从一个目录移动另一个目录时，只是移动不存在的文件，或者文件内容新于目标目录相对应文件的内容。 -v --verbose 当操作 mv 命令时，显示翔实的操作信息。 mv file1 file2 移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。 mv -i file1 file2除了如果 file2 存在的话，在 file2 被重写之前，用户会得到提示信息外，这个和上面的选项一样。 mv file1 file2 dir1 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。 mv dir1 dir2 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1的内容到目录 dir2 中，同时删除目录 dir1。如果目录 dir2存在，移动目录 dir1（及它的内容）到目录 dir2。 rm应用 -i, --interactive 在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件 -r, --recursive 递归地删除文件，这意味着，如果要删除一个目录，而此目录又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 -f, --force 忽视不存在的文件，不显示提示信息。这选项颠覆了“–interactive”选项。 -v, --verbose 在执行 rm 命令时，显示翔实的操作信息。 ln 创建链接ln 命令即可创建硬链接，也可以创建符号链接。可以用其中一种方法来使用它：ln file link创建硬链接，和：ln -s item link创建符号链接，“item” 可以是一个文件或是一个目录。 使用命令 type –说明怎样解释一个命令名 which –显示会执行哪个可执行程序 man –显示命令手册页 apropos –显示一系列适合的命令 info –显示命令 info whatis –显示一个命令的简洁描述 alias –创建命令别名 type命令type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。它像这样工作：type command。 which命令为了确定所给定的执行程序的准确位置，使用 which命令： [me@linuxbox ~]$ which ls /bin/ls man命令许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页 (manpage)。一个特殊的叫做 man 的分页程序，可用来浏览他们。它是这样使用的：man program。 appopos命令apropos －显示适当的命令，也有可能搜索参考手册列表，基于某个关键字的匹配项。输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man 命令加上“-k” 选项，和 apropos 完成一样的功能。(在手册页搜素关键字) whatis命令whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明。 info命令info －显示程序 Info 条目。GNU 项目提供了一个命令程序手册页的替代物，称为 “info”。info 内容可通过 info 阅读器程序读取。info 页是超级链接形式的，和网页很相似。 alias命令alias name=&#39;string&#39;创建自己的命令，删除别名使用 unalias 命令。 重定向—&gt;`&lt;`shell 内部参考标准输入，输出和错误为各自的文件描述符 0，1 和 2。shell 提供了一种表示法来重定向文件，使用文件描述符。 cat －连接文件 sort －排序文本行 uniq －报道或省略重复行 grep －打印匹配行 wc －打印文件中换行符，字，和字节个数 head －输出文件第一部分 tail - 输出文件最后一部分 tee －从 Stdin 读取数据，并同时输出到 Stdout 和文件 cat命令cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样:cat [file] 管道线命令可以从标准输入读取数据，然后再把数据输送到标准输出，命令的这种能力被一个shell 特性所利用，这个特性叫做管道线。使用管道操作符 “|”（竖杠），一个命令的标准输出可以管道到另一个命令的标准输入：command1 | command2 过滤器管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。举例：ls /bin /usr/bin | sort | less uniq命令uniq 从标准输入或单个文件名参数接受数据有序列表（详情查看 uniq 手册页），默认情况下，从数据列表中删除任何重复行。加-d后显示重复行。 wc命令wc（字计数）命令是用来显示文件所包含的行，字和字节数。 grep命令grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：grep pattern [file...]grep 有－对方便的选项：“-i” 导致 grep 忽略大小写当执行搜索时（通常，搜索是大小写敏感的），“-v” 选项会告诉 grep 只打印不匹配的行。 head/tail命令有时候不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。head命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令都打印十行文本，但是可以通过 “-n” 选项来调整命令打印的行数。 tee命令tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。]]></content>
      <categories>
        <category>SHELL</category>
        <category>学习</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>shell</tag>
        <tag>提示符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL 提示符学习汇总_2]]></title>
    <url>%2F2018%2F11%2F25%2FSHELL%20%E6%8F%90%E7%A4%BA%E7%AC%A6%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB_2%2F</url>
    <content type="text"><![CDATA[上一篇更新到重定向命令，后来感觉也没怎么用到那些命令。不过既然是技术博客、为了防止忘记，我还是会把一些不一定会用到的命令记录下来，以备以后查阅！ 键盘高级操作技巧 clear -清空屏幕 history -显示历史列表内容 移动光标 Ctrl-a 移动光标到行首。 Ctrl-e 移动光标到行尾。 94Ctrl-f 光标前移一个字符;和右箭头作用一样。 Ctrl-b 光标后移一个字符;和左箭头作用一样。 Alt-f 光标前移一个字。 Alt-b 光标后移一个字。 Ctrl-l 清空屏幕,移动光标到左上角。clear 命令完成同样的工作。 修改文本 Ctrl-d 删除光标位置的字符。 Ctrl-t 光标位置的字符和光标前面的字符互换位置。 Alt-t 光标位置的字和其前面的字互换位置。 Alt-l 把从光标位置到字尾的字符转换成小写字母。 Alt-u 把从光标位置到字尾的字符转换成大写字母。 剪切和粘贴文本 Ctrl-k 剪切从光标位置到行尾的文本。 Ctrl-u 剪切从光标位置到行首的文本。 Alt-d 剪切从光标位置到词尾的文本。 Alt-Backspace 剪切从光标位置到词头的文本。如果光标在一个单词的开头,剪切前一个单词。 Ctrl-y把剪切环中的文本粘贴到光标位置。 利用历史命令 history | less浏览历史命令(在默认情况下,bash 会存储你所输入的最后 500 个命令) bash 也具有按递增顺序来搜索历史列表的能力。这意味着随着字符的输入,我们可以告诉 bash 去搜索历史列表,每一个附加字符都进一步提炼我们的搜索。启动递增搜索,输入 Ctrl-r,其后输入你要寻找的文本。当你找到它以后,你可以敲入 Enter 来执行命令,或者输入 Ctrl-j,从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r,来找到下一个匹配项(向上移动历史列表)。输入 Ctrl-g 或者 Ctrl-c,退出搜索历史命令展开 !!重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。 !number 重复历史列表中第 number 行的命令。 !string 重复最近历史列表中,以这个字符串开头的命令。 !?string 重复最近历史列表中,包含这个字符串的命令。 权限（我喜欢Linux是因为这个系统主动性强，权限控制好，所以这一章看的我头皮发麻） id –显示用户身份号 chmod –更改文件模式 umask –设置默认的文件权限 su –以另一个用户的身份来运行 shell sudo –以另一个用户的身份来执行命令 chown –更改文件所有者 chgrp –更改文件组所有权 passwd –更改用户密码 读取、写入和执行-rw-rw-r– _1 _me_me_0_ 2008-03-06 14:52 foo.txt - 一个普通文件 d 一个目录 l一个符号链接。注意对于符号链接文件,剩余的文件属性总是”rwxrwxrwx”,而且都是虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 c一个字符设备文件。这种文件类型是指按照字节流,来处理数据的设备。比如说终端机,或者调制解调器 b一个块设备文件。这种文件类型是指按照数据块,来处理数据的设备,例如一个硬盘,或者 CD-ROM 盘。 剩下的九个字符,叫做文件模式,代表着文件所有者,文件组所有者,和其他人的读,写,执行权限。 chmod -更改文件模式更改文件或目录的模式(权限),可以利用 chmod 命令。注意只有文件的所有者或者超级用户才能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式:八进制数字表示法,或符号表示法。 0 000 -– 1 001 –x 2 010 -w- 3 011 -wx 4 100 r– 5 101 r-x 6 110 rw- 7 111 rwx 通过使用 3 个八进制数字,我们能够设置文件所有者,用户组,和其他人的权限. chmod 命令支持一种符号表示法,来指定文件模式。符号表示法分为三部分:更改会影响谁,要执行哪个操作,要设置哪种权限。通过字符“u”,“g”,“o”,和“a”的组合来指定要影响的对象,如下所示: u ”user” 的简写,意思是文件或目录的所有者。 g 用户组。 o ”others” 的简写,意思是其他所有的人。 a ”all” 的简写,是”u”, ”g” 和“o”三者的联合。如果没有指定字符,则假定使用 “all”。执行的操作可能是一个“+”字符,表示加上一个权限,一个“-”,表示删掉一个权限,或者是一个“=”,表示只有指定的权限可用,其它所有的权限被删除。权限由“r”,“w”,和“x”来指定。这里是一些符号表示法的举例： u+x 为文件所有者添加可执行权限。 u-x 删除文件所有者的可执行权限。 +x 为文件所有者,用户组,和其他所有人添加可执行权限。等价于 a+x。 o-rw 除了文件所有者和用户组,删除其他人的读权限和写权限。 go=rw 给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限,他们将被移除。 u+x、go=rw 给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。 更改身份 注销系统并以其他用户身份重新登录系统。 使用 su 命令。 -以其他用户身份和组 ID 运行一个 shell 使用 sudo 命令。以另一个用户身份执行命令 chown -更改文件所有者和用户组chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。chown 命令的语法:chown [owner][:[group]] file... bob把文件所有者从当前属主更改为用户 bob bob:users把文件所有者改为用户 bob,文件用户组改为用户组 users :admins把文件用户组改为组 admins,文件所有者不变 bob:文件所有者改为用户 bob,文件用户组改为,用户 bob 登录系统时,所属的用户组 chgrp -更改用户组所有权在旧版 Unix 系统中,chown 命令只能更改文件所有权,而不是用户组所有权。为了达到目的,使用一个独立的命令,chgrp 来完成。除了限制多一点之外,chgrp 命令与 chown 命令使用起来很相似。 更改用户密码使用 passwd 命令,来设置或更改用户密码。命令语法:passwd [user]passwd 命令将会试着强迫你使用“强”密码。这意味着,它会拒绝接受太短的密码,与先前相似的密码,字典中的单词作为密码,或者是太容易猜到的密码 进程 ps –报告当前进程快照 top –显示任务 jobs –列出活跃的任务 bg –把一个任务放到后台执行 fg –把一个任务放到前台执行 kill –给一个进程发送信号 killall –杀死指定名字的进程 shutdown –关机或重启系统 查看进程比较常用的是ps命令：12345[me@linuxbox ~]$ psPID TTYTIME CMD5198 pts/1 00:00:00 bash10129 pts/1 00:00:00 ps TTY 是 “Teletype” 的简写,是指进程的控制终端。这里,Unix 展示它的年龄。TIME 字段表示进程所消耗的 CPU 时间数量。如果给 ps 命令加上选项,我们可以得到更多关于系统运行状态的信息:12345[me@linuxbox ~]$ ps xPID TTY STAT TIME COMMAND2799 ? Ssl 0:00 /usr/libexec/bonobo-activation-server – ac2820 ? Sl 0:01 /usr/libexec/evolution-data-server-1.10 --and many more.. 用 top 命令动态查看进程虽然 ps 命令能够展示许多计算机运行状态的信息,但是它只是提供,ps 命令执行时刻的机器状态快照。为了看到更多动态的信息,我们使用 top 命令:[me@linuxbox ~]$ toptop 程序连续显示系统进程更新的信息(默认情况下,每三分钟更新一次),“top” 这个名字来源于这个事实,top 程序是用来查看系统中“顶端”进程的。top 显示结果由两部分组成:最上面是系统概要,下面是进程列表,以 CPU 的使用率排序。1234567891011121314151617181920212223top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00Tasks: 109 total,1 running,106 sleeping,0 stopped,2 zombieCpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%siMem: 319496k total, 314860k used, 4636k free,Swap: 875500k total, 149128k used, 726372k free,PID6244USER PR NI VIRT RES SHRme 39 19 31752 3124 2188S %CPUS6.319392k buff114676k cach%MEM1.0TIME+16:24.42 trackerd.... 其中系统概要包含许多有用信息。下表是对系统概要的说明: 行号 字段 意义 1 top 程序名 14:59:20 当前时间 up 6:30 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。在这个例子里,系统已经运行了六个半小时 2users 有两个用户登录系统 load average: 加载平均值是指,等待运行的进程数目,也就是说,处于运行状态的进程个数,这些进程共享 CPU。展示了三个数值,每个数值对应不同的时间周期。第一个是最后 60 秒的平均值,下一个是前 5 分钟的平均值,最后一个是前 15 分钟的平均值。若平均值低于 1.0,则指示计算机工作不忙碌 2 Tasks: 总结了进程数目和各种进程状态 3 Cpu(s): 这一行描述了 CPU 正在执行的进程的特性 0.7%us 0.7% of the CPU is being used for user processes. 这意味着进程在内核之外 1.0%sy 1.0% 的 CPU 时间被用于系统(内核)进程 0.0%ni 0.0% 的 CPU 时间被用于”nice”(低优先级)进程 98.3%id 98.3% 的 CPU 时间是空闲的 0.0%wa 0.0% 的 CPU 时间来等待 I/O 4 Mem: 展示物理内存的使用情况 5 Swap: 展示交换分区(虚拟内存)的使用情况 top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h,显示程序的帮助屏幕,q,退出 top 程序。 中断一个进程在一个终端中,输入 Ctrl-c,中断一个程序。这意味着,我们礼貌地要求终止这个程序。通过这个技巧,许多(但不是全部)命令行程序可以被中断。 把一个进程放置到后台 (执行)把终端看作是一个有前台(表层放置可见的事物,像 shell 提示符)和后台(表层之下放置隐藏的事物)(的设备)。启动一个程序,让它立即在后台运行,我们在程序命令之后,加上 “&amp;” 字符.123[me@linuxbox ~]$ xlogo &amp;[1] 28236[me@linuxbox ~]$ 执行命令之后,这个 xlogo 窗口出现,并且 shell 提示符返回,同时打印一些有趣的数字。这条信息是 shell 特性的一部分,叫做工作控制。通过这条信息,shell 告诉我们,已经启动了工作号为 1(“[1]”),PID 为 28236 的程序。工作控制,这个 shell 功能可以列出从终端中启动的任务。执行 jobs 命令,我们可以看到这个输出列表:123[me@linuxbox ~]$ jobs[1]+ Runningxlogo &amp; 进程返回到前台一个在后台运行的进程对一切来自键盘的输入都免疫,也不能用 Ctrl-c 来中断它。使用 fg命令,让一个进程返回前台执行:12345[me@linuxbox ~]$ jobs[1]+ Runningxlogo &amp;[me@linuxbox ~]$ fg %1xlogo fg 命令之后,跟随着一个百分号和工作序号(叫做 jobspec)。如果我们只有一个后台任务,那么 jobspec 是可有可无的。输入 Ctrl-c 来终止 xlogo 程序。 停止一个进程有时候,我们想要停止一个进程,而没有终止它。这样会把一个前台进程移到后台等待。输入 Ctrl-z,可以停止一个前台进程。使用 fg 命令,可以恢复已经停止的程序到前台运行,或者用 bg 命令把程序移到后台。 通过 kill 命令给进程发送信号kill 命令被用来给程序发送信号。它最常见的语法形式看起来像这样:kill [-signal] PID... 1 HUP 挂起。这是美好往昔的痕迹,那时候终端机通过电话线和调制解调器连接到远端的计算机。这个信号被用来告诉程序,控制的终端机已经“挂起”。通过关闭一个终端会话,可以说明这个信号的作用。发送这个信号到终端机上的前台程序,程序会终止。许多守护进程也使用这个信号,来重新初始化。这意味着,当发送这个信号到一个守护进程后,这个进程会重新启动,并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。 2 INT 中断。实现和 Ctrl-c 一样的功能,由终端发送。通常,它会终止一个程序。 9 KILL 杀死。这个信号很特别。鉴于进程可能会选择不同的方式,来处理发送给它的信号,其中也包含忽略信号,这样呢,从不发送 Kill 信号到目标进程。而是内核立即终止这个进程。当一个进程以这种方式终止的时候,它没有机会去做些“清理”工作,或者是保存劳动成果。因为这个原因,把 KILL 信号看作杀手锏,当其它终止信号失败后,再使用它。 15 TERM 终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”,可以接受信号,那么这个信号终止。 18 CONT 继续。在停止一段时间后,进程恢复运行。 19 STOP 停止。这个信号导致进程停止运行,而没有终止。像KILL 信号,它不被发送到目标进程,因此它不能被忽略。 除了以上列出的 kill 命令最常使用的信号之外,还有一些系统频繁使用的信号。以下是其它一些常用信号列表: ３ QUIT 退出 11 SEGV 段错误。如果一个程序非法使用内存,就会发送这个信号。也就是说,程序试图写入内存,而这个内存空间是不允许此程序写入的。 20 TSTP 终端停止。当按下 Ctrl-z 组合键后,终端发送这个信号。不像 STOP 信号,TSTP 信号由目标进程接收,且可能被忽略。 28 WINCH 改变窗口大小。当改变窗口大小时,系统会发送这个信号。一些程序,像 top 和 less 程序会响应这个信号,按照新窗口的尺寸,刷新显示的内容。 呼，写着写着就写不完了。本来打算就写四千字左右的，没想到不小心写了七千、就这样吧，剩下的在写一篇也就差不多完了。好长时间没有写博客了，十天后我要参加计算机考试，可是现在还没学会，加油！你是最棒的！－－范儿]]></content>
      <categories>
        <category>SHELL</category>
        <category>学习</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>shell</tag>
        <tag>提示符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2F2018%2F11%2F25%2FREADME%2F</url>
    <content type="text"><![CDATA[README该文件用来测试和展示书写README的各种markdown语法。GitHub的markdown语法在标准的markdown语法基础上做了扩充，称之为GitHub Flavored Markdown。简称GFM，GFM在GitHub上有广泛应用，除了README文件外，issues和wiki均支持markdown语法。 转自： Author 果冻虾仁 E-mail Jelly.K.Wang@qq.com 目录 横线 标题 文本 普通文本 单行文本 多行文本 文字高亮 换行 斜体 粗体 删除线 图片 来源于网络的图片 GitHub仓库中的图片 链接 文字超链接 链接外部URL 链接本仓库里的URL 锚点 图片链接 列表 无序列表 有序列表 复选框列表 块引用 代码高亮 表格 表情 diff语法 横线 ***、—、___可以显示横线效果 标题一级标题二级标题三级标题四级标题五级标题六级标题文本普通文本这是一段普通的文本 单行文本Hello,大家好，我是果冻虾仁。 在一行开头加入1个Tab或者4个空格。 文本块语法1在连续几行的文本开头加入1个Tab或者4个空格。 欢迎到访 很高兴见到您 祝您，早上好，中午好，下午好，晚安 语法2使用一对各三个的反引号：123欢迎到访我是C++码农你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我 该语法也可以实现代码高亮，见代码高亮 文字高亮文字高亮功能能使行内部分文字高亮，使用一对反引号。语法：1`linux` `网络编程` `socket` `epoll` 效果：linux 网络编程 socket epoll 也适合做一篇文章的tag 换行直接回车不能换行，可以在上一行文本后面补两个空格，这样下一行的文本就换行了。 或者就是在两行文本直接加一个空行。 也能实现换行效果，不过这个行间距有点大。 斜体、粗体、删除线 语法 效果 *斜体1* 斜体1 _斜体2_ 斜体2 **粗体1** 粗体1 __粗体2__ 粗体2 这是一个 ~~删除线~~ 这是一个 删除线 ***斜粗体1*** 斜粗体1 ___斜粗体2___ 斜粗体2 ***~~斜粗体删除线1~~*** 斜粗体删除线1 ~~***斜粗体删除线2***~~ 斜粗体删除线2 斜体、粗体、删除线可混合使用 图片基本格式：1![alt](URL title) alt和title即对应HTML中的alt和title属性（都可省略）： alt表示图片显示失败时的替换文本 title表示鼠标悬停在图片时的显示文本（注意这里要加引号） URL即图片的url地址，如果引用本仓库中的图片，直接使用相对路径就可了，如果引用其他github仓库中的图片要注意格式，即：仓库地址/raw/分支名/图片路径，如：1https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif # 语法 效果 1 ![baidu](http://www.baidu.com/img/bdlogo.gif &quot;百度logo&quot;) 2 ![][foryou] 注意例2的写法使用了URL标识符的形式，在链接一节有介绍。 在文末有foryou的定义：1[foryou]:https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif 链接链接外部URL # 语法 效果 1 [我的博客](http://blog.csdn.net/guodongxiaren &quot;悬停显示&quot;) 我的博客 2 [我的知乎][zhihu] 我的知乎 语法2由两部分组成： 第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（姑且称之为URL标识符） 第二部分标记实际URL。 使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。 URL标识符是我起的名字，不知道是否准确。囧。。 链接本仓库里的URL 语法 效果 [我的简介](/example/profile.md) 我的简介 [example](./example) example 图片链接给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。 # 语法 效果 1 [![weibo-logo]](http://weibo.com/linpiaochen) 2 [![](/img/zhihu.png &quot;我的知乎，欢迎关注&quot;)][zhihu] 3 [![csdn-logo]][csdn] [![csdn-logo]][csdn] 因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。 本文URL标识符都放置于文末 锚点其实呢，每一个标题都是一个锚点，和HTML的锚点（#）类似，比如我们 语法 效果 [回到顶部](#readme) 回到顶部 不过要注意，标题中的英文字母都被转化为小写字母了。 以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！ 列表无序列表语法123* 昵称：果冻虾仁- 别名：隔壁老王* 英文名：Jelly 效果 昵称：果冻虾仁 别名：隔壁老王 英文名：Jelly 多级无序列表语法123* 编程语言 * 脚本语言 * Python 效果 编程语言 脚本语言 Python 一级有序列表语法就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。12345面向对象的三个基本特征：1. 封装2. 继承3. 多态 效果面向对象的三个基本特征： 封装 继承 多态 多级有序列表和无序列表一样，有序列表也有多级结构。 语法1231. 这是一级的有序列表，数字1还是1 1. 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 1. 这是三级的有序列表，数字在显示的时候变成了英文字母 效果 这是一级的有序列表，数字1还是1 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 这是三级的有序列表，数字在显示的时候变成了英文字母 复选框列表语法123456- [x] 需求分析- [x] 系统设计- [x] 详细设计- [ ] 编码- [ ] 测试- [ ] 交付 效果 需求分析 系统设计 详细设计 编码 测试 交付 您可以使用这个功能来标注某个项目各项任务的完成情况。 Tip: 在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。 块引用常用于引用文本文本摘自《深入理解计算机系统》P27 令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。 “端”（endian）的起源以下是Jonathan Swift在1726年关于大小端之争历史的描述：“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。” 块引用有多级结构语法12345&gt; 数据结构&gt;&gt; 树&gt;&gt;&gt; 二叉树&gt;&gt;&gt;&gt; 平衡二叉树&gt;&gt;&gt;&gt;&gt; 满二叉树 效果 数据结构 树 二叉树 平衡二叉树 满二叉树 代码高亮语法在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。 效果1public static void main(String[]args)&#123;&#125; //Java 1int main(int argc, char *argv[]) //C 1echo "hello GitHub" #Bash 1document.getElementById("myH1").innerHTML="Welcome to my Homepage"; //javascipt 1string &amp;operator+(const string&amp; A,const string&amp; B) //cpp 表格 表头1 表头2 表格单元 表格单元 表格单元 表格单元 表头1 表头2 表格单元 表格单元 表格单元 表格单元 对齐表格可以指定对齐方式 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 混合其他语法表格单元中的内容可以和其他大多数GFM语法配合使用，如： 使用普通文本的删除线，斜体等效果 名字 描述 Help Display the help window. Close Closes a window 表格中嵌入图片（链接）其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。 图片 描述 百度 表情Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。 比如:blush:，可以显示:blush:。 具体每一个表情的符号码，可以查询GitHub的官方网页http://www.emoji-cheat-sheet.com。 但是这个网页每次都打开奇慢。。所以我整理到了本repo中，大家可以直接在此查看emoji。 diff语法版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。 语法其语法与代码高亮类似，只是在三个反引号后面写diff，并且其内容中，以 +开头表示新增，-开头表示删除。 效果12+ 鸟宿池边树，僧敲月下门- 鸟宿池边树，僧推月下门]]></content>
      <categories>
        <category>Git</category>
        <category>Github</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Giehub学习</tag>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPT制作技巧汇总]]></title>
    <url>%2F2018%2F11%2F25%2FPPT%E5%88%B6%E4%BD%9C%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[对于很多人来说做ppt的时候往往会感到无从下手，这个时候你就需要一个完整的作品，或者一张具有设计感的海报，来激发你体内的洪荒之力。 PPT灵感网站Color Claim配色网站，每一种颜色都经过知名设计师精心挑选，并且每种颜色都提供了相应的数值，还可以下载样板色，值得一提的是，该网站在提供每钟颜色，都搭配着对应的其他颜色。 behance国外著名的设计师网站，里面聚集了世界各地的设计师优秀作品，并且该网站的分类非常齐全，无论你做哪方面的PPT，都能在这里找到你所需要的作品。 zcool国内设计师网站，种类繁多涉及的领域也比较广泛，其中包括建筑，摄影，平面，3D等，总有一个风格适合你的PPT。 dribbble国外著名的设计师交流平台，这里的每一个作品，都提供了制作中所用颜色的数值，可以帮助你解决制作PPt中，色彩搭配的问题，该网站还有自己的App,为你寻找灵感节约了更多的时间。 PPT模板下载网站我从来都不提倡使用模板制作 PPT ，一是因为你能下载的 PPT 模板特别是免费的模板，都丑到爆；二是因为如果你经常依赖 PPT 模板，和宠坏了的孩子无异。但人人应该都有赶时间的时候，以下就是我所推荐的 5 个免费实用的 PPT 模板下载网站。 office plusoffice官方模板网站，该网站可以提供ppt,word文档，Excel以及图片素材的模板，还可以根据你的个人口味，选择不同的风格，不过该网站的内容只能用于个人非商业用途。 slidemodel国外的PPT模板网站，网站绝大部分的PPT都是图标或者图形类型的，而且还添加了地图类型的ppt模板，虽然这些都是需要付费订阅，但网站每周会提供150个免费的ppt模板，注册后均可下载。 presentationmagazine网站模板内容非常齐全，大部分的模板都可以免费使用，还免费提供一些制作 PPT 时所用到背景元素，如果你在PPT的制作过程中遇到什么困难，可以在网站的官方论坛上提出来。 slidehunter4000个完全免费ppt模板网站，不管你做什么工作，都能在网站中找到相应的 PPT 模板，有趣的是网站还提供3D类型的 PPT，感兴趣的朋友可以去了解一下。 AllPPT网站设计简洁大方，种类也比较齐全，并且还有4；3的模板下载，如果你不会 PPT，他们还提供了 PPT 学习网站，以及免版权的图片使用网站，该网站每周会更新30个精美的ppt模板提供下载。 PPT插件老实说 PPT 里面的内容已经够我们头疼了，还要把 PPT 变得高大上的效果，那就相当的麻烦了。不过这里我们为大家推荐几款高效的 PPT 插件。 iSlideiSlide 是一款基于 PowerPoint 的插件工具，即便您不懂设计，也能简单、高效地创建各类专业PPT演示文档。拥有近数十万 PPT 模板，而且还会持续更新。你可以快速检索、一键插入PPT 。另外，使用 iSlide 智能图表可以让数据变得直观易懂！ 目前 ，iSlide 已经全面支持微软 Office 以及金山 WPS。 口袋动画口袋动画分为盒子版和专业版。盒子版是 PPT 小白专属工具；专业版是 PPT 进阶级变身，无论使用哪个版本，都能让你快速制作出媲美 AE 特效水准的 PPT 动画。 同时它还拥有一键美化功能，覆盖片头、片尾、图表等多场景动画，还有各种组合、单一动画。仅需一键下载，既可替换元素，生成酷炫动画展示页。 目前这款插件同时支持微软 Office 和金山 WPS 。 OneKeyToolsOneKeyTools 简称 “OK插件” 或 “OK” ，是一款免费开源的 PPT 设计辅助插件。功能覆盖形状、图片、调色、表格、图表、音频、辅助等领域。 目前支持微软 Office 2013 及以上版本。 PPT 美化大师PPT 美化大师拥有海量在线模板素材。专业模板、精美图示、创意画册、实用形状等，细致分类，内容也会持续更新。最大的特点是支持一键全自动智能美化，让精美的 PPT变得简单起来。同时，它还支持将 PPT 一键生成不能复制、修改的只读格式。 目前，PPT 美化大师都支持微软 Office 和金山 WPS 。 ispring suite作为教师或者课程开发者，我们可能会有制作在线课程的需要，而这款名为 ispring suite 的 PPT 插件可以帮你把普通的 PPT 演示文档转换为适合在 Windows、Mac、iPad、iPhone、Android 等多种平台独立使用的在线课程。你可以将 PPT 生成为 H5 或者 Flash ，也可以集成为 exe 格式的软件或者 MP4 视频。 目前这款插件并不支持 WPS ，适配微软的 Office 2007 及以上版本。 希望我家的冷冷能把PPT做好！ｅｍｍｍｍｍｍｍ，加油。]]></content>
      <categories>
        <category>高效率生活</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>PPT</tag>
        <tag>技巧</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github了解--Git指令]]></title>
    <url>%2F2018%2F11%2F25%2FGithub%E4%BA%86%E8%A7%A3--Git%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言Git 仓库管理功能是 GitHub 的核心。因此,使用 GitHub 之前必须先掌握 Git 的相关知识,同时本地的设备还要安装 Git 的环境。这篇文章就写写安装使用 Git 所需的知识及各种设置。 Git 安装 最近的 Mac os 中都预装了 Git。而各版本的 Linux 中也都以软件包(Package)的形式提供给用户了,所以可以直接使用而不需要安装。 在 Wi n d o w s 环境中,最简单快捷的方法是使用 msysGitA 。请按 照 Downloads 的 向 导 下 载 安 装 包。安装包下载完毕后,只要双击运行,按照向导一步步安装即可。&amp;nbsp顺利安装好 msysGit 之后,Git Bash 会作为一个应用程序添加进系统,接下来请启动它。双击之后,会弹出一个名为 Git Bash 的命令提示符,它附属于 msysGit。 Git 初始设置首先来设置使用 Git 时的姓名和邮箱地址。名字要用英文输入。 $ git config --global user.name &quot;Firstname Lastname&quot;$ git config --global user.email &quot;your_email@example.com&quot;这个命令,会在“~/.gitconfig”中以如下形式输出设置文件。 [user] name = Firstname Lastname email = your_email@example.com 使用前的设置 在Github创建账户，并完善个人信息 设置 SSH Key（这个比较重要，用于仓库链接）运行下面的命令创建 SSH Key$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;Generating public/private rsa key pair.Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa): 按回车键Enter passphrase (empty for no passphrase): 输入密码Enter same passphrase again: 再次输入密码“your_email@example.com”的部分请改成您在创建账户时用的邮箱地址。密码需要在认证时输入,请选择复杂度高并且容易记忆的组合。输入密码后会出现以下结果。Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.The key fingerprint is:fingerprint值 your_email@example.com The key&#39;s randomart image is:+--[ RSA 2048]----+略 id_rsa 文件是私有密钥,id_rsa.pub 是公开密钥。 添加公开密钥在 GitHub 中添加公开密钥,今后就可以用私有密钥进行认证了。点击右上角的账户设定按钮(Account Settings),选择 SSH Keys 菜单。点击 Add SSH Key 之后,会出现输入框。在 Title 中输入适当的密钥名称。Key 部分请粘贴 id_rsa.pub 文件里的内容。id_rsa.pub的内容可以用如下方法查看。$ cat ~/.ssh/id_rsa.pubssh-rsa 公开密钥的内容 your_email@example.com SSH Keys添加成功之后,创建账户时所用的邮箱会接到一封提示“公共密钥添加完成”的邮件。 完成以上设置后,就可以用手中的私人密钥与 GitHub 进行认证和通信了。可以用下面代码试试有木有成功。$ ssh -T git@github.comThe authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is fingerprint值 .Are you sure you want to continue connecting (yes/no)? 输入yes 出现如下结果即为成功。Hi hirocastest! You&#39;ve successfully authenticated, but GitHub does not provide shell access. Git 基础操作git init——初始化仓库要使用 Git 进行版本管理,必须先初始化仓库。Git 是使用git init命令进行初始化的。请实际建立一个目录并初始化仓库。 $ mkdir git-tutorial$ cd git-tutorial$ git initInitialized empty Git repository in /Users/hirocaster/github/github-book /git-tutorial/.git/ 如果初始化成功,执行了 git init命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。在 Git 中,我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行,然后记录到仓库中,以此管理文件的历史快照。如果想将文件恢复到原先的状态,可以从仓库中调取之前的快照,在工作树中打开。开发者可以通过这种方式获取以往的文件。 clone 已有仓库$ git clone git@github.com:hirocastest/Hello-World.gitCloning into &#39;Hello-World&#39;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Receiving objects: 100% (3/3), done.$ cd Hello-World这里会要求输入 GitHub 上设置的公开密钥的密码。认证成功后,仓库便会被 clone 至仓库名后的目录中。将想要公开的代码提交至这个仓库再 push 到 GitHub 的仓库中,代码便会被公开。 git status——查看仓库的状态git status命令用于显示 Git 仓库的状态。工作树和仓库在被操作的过程中,状态会不断发生变化。在 Git 操作过程中时常用 git status命令查看当前状态,可谓基本中的基本。下面,就让我们来实际查看一下当前状态。 $ git status# On branch master## Initial commit#nothing to commit (create/copy files and use &quot;git add&quot; to track) 结果显示了我们当前正处于 master 分支下。关于分支我们会在后面博客里写,现在不必深究。接着还显示了没有可提交的内容。所谓提交(Commit),是指“记录工作树中所有文件的当前状态”。尚没有可提交的内容,就是说当前我们建立的这个仓库中还没有记录任何文件的任何状态。这里,我们建立 README.md 文件作为管理对象,为第一次提交做前期准备。 $ touch README.md$ git status# On branch master## Initial commit`## Untracked files:#｀ (use “git add …” to include in what will be committed)##README.mdnothing added to commit but untracked files present (use “git add” totrack)` 可以看到在 Untracked files 中显示了 README.md 文件。类似地,只要对 Git 的工作树或仓库进行操作,git status命令的显示结果就会发生变化。 git add——向暂存区中添加文件如果只是用 Git 仓库的工作树创建了文件,那么该文件并不会被记入 Git 仓库的版本管理对象当中。因此我用 git status命令查看README.md 文件时,它会显示在 Untracked files 里。要想让文件成为 Git 仓库的管理对象,就需要用 git add命令将其加入暂存区(Stage 或者 Index)中。暂存区是提交之前的一个临时区域。 $ git add README.md$ git status # On branch master # # Initial commit # # Changes to be committed: # (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) # # new file: README.md # 将 README.md 文件加入暂存区后,git status命令的显示结果 发 生 了 变 化。 可 以 看 到,README.md 文 件 显 示 在 Changes to be committed 中了。 git commit——保存仓库的历史记录git commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录,我们就可以在工作树中复原文件,记述一行提交信息.我们来实际运行一下 git commit命令。 $ git commit -m &quot;First commit&quot;[master (root-commit) 9f129ba] First commit1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 README.md -m 参数后的 “First commit”称作提交信息,是对这个提交的概述。记述详细提交信息刚才我只简洁地记述了一行提交信息,如果想要记述得更加详细,请不加 - m,直接执行 g i t c o m m i t命令。执行后编辑器就会启动,并显示如下结果。 # # # # # Please enter the commit message for your changes. Lines starting with &#39;#&#39; will be ignored, and an empty message aborts the commit. On branch master Initial commit # # Changes to be committed: # (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) ##new file: README.md # 在编辑器中记述提交信息的格式如下。● 第一行:用一行文字简述提交的更改内容● 第二行:空行● 第三行以后:记述更改的原因和详细内容只要按照上面的格式输入,今后便可以通过确认日志的命令或工具看到这些记录。 在以 #(井号)标为注释的 Changes to be committed(要提交的更改)栏中,可以查看本次提交中包含的文件。将提交信息按格式记述完毕后,请保存并关闭编辑器,以 #(井号)标为注释的行不必删除。随后,刚才记述的提交信息就会被提交。 中止提交如果在编辑器启动后想中止提交,请将提交信息留空并直接关闭编辑器,随后提交就会被中止。 查看提交后的状态执行完 git commit命令后再来查看当前状态。 $ git status # On branch master nothing to commit, working directory clean 当前工作树处于刚刚完成提交的最新状态,所以结果显示没有更改。 git log——查看提交日志g i t l o g命令可以查看以往仓库中提交的日志。包括可以查看什么人在什么时候进行了提交或合并,以及操作前后有怎样的差别。关于合并我会在后面解说。我们先来看看刚才的 git commit命令是否被记录了。 $ git logcommit 9f129bae19b2c82fb4e98cde5890e52a6c546922Author: hirocaster &lt;hohtsuka@gmail.com&gt;Date:Sun May 5 16:06:49 2013 +0900First commit 显示了刚刚的提交操作。commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值。Git 的其他命令中,在指向提交时会用到这个哈希值。Author 栏中显示我们给 Git 设置的用户名和邮箱地址。Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。只显示提交信息的第一行.如果只想让程序显示第一行简述信息,可以在 git log命令后加上 –pretty=short。这样一来开发人员就能够更轻松地把握多个提交。 $ git log --pretty=shortcommit 9f129bae19b2c82fb4e98cde5890e52a6c546922Author: hirocaster &lt;hohtsuka@gmail.com&gt;First commit 只显示指定目录、文件的日志只要在 git log命令后加上目录名,便会只显示该目录下的日志。如果加的是文件名,就会只显示与该文件相关的日志。$ git log README.md 显示文件的改动如果想查看提交所带来的改动,可以加上 - p参数,文件的前后差别就会显示在提交信息之后。 $ git log -p 比如,执行下面的命令,就可以只查看 README.md 文件的提交日志以及提交前后的差别。 $ git log -p README.md 如上所述,g i t l o g命令可以利用多种参数帮助开发者把握以往提交的内容。不必勉强自己一次记下全部参数,每当有想查看的日志就积极去查,慢慢就能得心应手了。 git diff——查看更改前后的差别git diff命令可以查看工作树、暂存区、最新提交之间的差别。单从字面上可能很难理解,各位不妨跟着笔者的解说亲手试一试。我们在刚刚提交的 README.md 中写点东西。 # Git教程 这里用 Markdown 语法写下了一行题目。查看工作树和暂存区的差别,执行 git diff命令,查看当前工作树与暂存区的差别。$ git diffdiff --git a/README.md b/README.mdindex e69de29..cb5dc9f 100644--- a/README.md+++ b/README.md@@ -0,0 +1 @@+# Git教程 由于我尚未用 git add命令向暂存区添加任何东西,所以程序只会显示工作树与最新提交状态之间的差别。这里解释一下显示的内容。“+”号标出的是新添加的行,被删除的行则用“-”号标出。我们可以看到,这次只添加了一行。用 git add命令将 README.md 文件加入暂存区。$ git add README.md 查看工作树和最新提交的差别，如果现在执行 git diff命令,由于工作树和暂存区的状态并无差别,结果什么都不会显示。要查看与最新提交的差别,请执行以下命令。$ git diff HEADdiff --git a/README.md b/README.mdindex e69de29..cb5dc9f 100644--- a/README.md+++ b/README.md@@ -0,0 +1 @@+# Git教程 不妨养成这样一个好习惯:在执行 git commit命令之前先执行git diff HEAD命令,查看本次提交与上次提交之间有什么差别,等确认完毕后再进行提交。这里的 HEAD 是指向当前分支中最新一次提交的指针。由于我们刚刚确认过两个提交之间的差别,所以直接运行 g i t commit命令。 $ git commit -m &quot;Add index&quot;[master fd0cbf0] Add index1 file changed, 1 insertion(+) 保险起见,我们查看一下提交日志,确认提交是否成功。 $ git logcommit fd0cbf0d4a25f747230694d95cac1be72d33441dAuthor: hirocaster &lt;hohtsuka@gmail.com&gt;Date:Sun May 5 16:10:15 2013 +0900Add indexcommit 9f129bae19b2c82fb4e98cde5890e52a6c546922Author: hirocaster &lt;hohtsuka@gmail.com&gt;Date:Sun May 5 16:06:49 2013 +0900First commit成功查到了第二个提交。 本文参考：《Github 入门与实践》 先写到这里吧，好累，尽量再接下的日子里写完这部博客，完成我的学习任务。加油！ －－－－2018年７月２2号凌晨一点二十二完－－－－范儿]]></content>
      <categories>
        <category>Git</category>
        <category>Github</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Giehub学习</tag>
        <tag>Git指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Functional Programming For The Rest of Us]]></title>
    <url>%2F2018%2F11%2F25%2FFunctional%20Programming%20For%20The%20Rest%20of%20Us%2F</url>
    <content type="text"><![CDATA[本文及翻译摘自Github@justjavac（迷渡） ============================================Monday, June 19, 2006 ###IntroductionProgrammers are procrastinators. Get in, get some coffee, check the mailbox, read the RSS feeds, read the news, check out latest articles on techie websites, browse through political discussions on the designated sections of the programming forums. Rinse and repeat to make sure nothing is missed. Go to lunch. Come back, stare at the IDE for a few minutes. Check the mailbox. Get some coffee. Before you know it, the day is over. The only thing, every once in a while challenging articles actually do pop up. If you’re looking at the right places you’ll find at least one of these every couple of days. These articles are hard to get through and take some time, so they start piling up. Before you know it, you have a list of links and a folder full of PDF files and you wish you had a year in a small hut in the middle of the forest with nobody around for miles so you could catch up. Would be nice if someone came in every morning while you’re taking a walk down the river to bring some food and take out the garbage. I don’t know about your list, but a large chunk of the articles in mine are about functional programming. These generally are the hardest to get through. Written in a dry academic language, even the “ten year Wall Street industry veterans” don’t understand what functional programming (also referred to as FP) articles are all about. If you ask a project manager in Citi Group or in Deutsche Bank1 why they chose to use JMS instead of Erlang they’ll say they can’t use academic languages for industrial strength applications. The problem is, some of the most complex systems with the most rigid requirements are written using functional programming elements. Something doesn’t add up. It’s true that FP articles and papers are hard to understand, but they don’t have to be. The reasons for the knowledge gap are purely historical. There is nothing inherently hard about FP concepts. Consider this article “an accessible guide to FP”, a bridge from our imperative minds into the world of FP. Grab a coffee and keep on reading. With any luck your coworkers will start making fun of you for your FP comments in no time. So what is FP? How did it come about? Is it edible? If it’s as useful as its advocates claim, why isn’t it being used more often in the industry? Why is it that only people with PhDs tend to use it? Most importantly, why is it so damn hard to learn? What is all this closure, continuation, currying, lazy evaluation and no side effects business? How can it be used in projects that don’t involve a university? Why does it seem to be so different from everything good, and holy, and dear to our imperative hearts? We’ll clear this up very soon. Let’s start with explaining the reasons for the huge gap between the real world and academic articles. The answer is as easy as taking a walk in the park. ###A Walk In The ParkFire up the time machine. Our walk in the park took place more than two thousand years ago, on a beautiful sunny day of a long forgotten spring in 380 B.C. Outside the city walls of Athens, under the pleasant shade of olive trees Plato was walking towards the Academy with a beautiful slave boy. The weather was lovely, the dinner was filling, and the conversation turned to philosophy. “Look at these two students”, said Plato carefully picking words to make the question educational. “Who do you think is taller?” The slave boy looked towards the basin of water where two men were standing. “They’re about the same height”, he said. “What do you mean ‘about the same’?”, asked Plato. “Well, they look the same from here but I’m sure if I were to get closer I’d see that there is some difference.” Plato smiled. He was leading the boy in the right direction. “So you would say that there is nothing perfectly equal in our world?” After some thinking the boy replied: “I don’t think so. Everything is at least a little different, even if we can’t see it.” The point hit home! “Then if nothing is perfectly equal in this world, how do you think you understand the concept of ‘perfect’ equality?” The slave boy looked puzzled. “I don’t know”, he replied. So was born the first attempt to understand the nature of mathematics. Plato suggested that everything in our world is just an approximation of perfection. He also realized that we understand the concept of perfection even though we never encountered it. He came to conclusion that perfect mathematical forms must live in another world and that we somehow know about them by having a connection to that “alternative” universe. It’s fairly clear that there is no perfect circle that we can observe. But we also understand what a perfect circle is and can describe it via equations. What is mathematics, then? Why is the universe described with mathematical laws? Can all of the phenomena of our universe be described by mathematics?2 Philosophy of mathematics is a very complex subject. Like most philosophical disciplines it is far more adept at posing questions rather than providing answers. Much of the consensus revolves around the fact that mathematics is really a puzzle: we set up a set of basic non-conflicting principles and a set of rules on how to operate with these principles. We can then stack these rules together to come up with more complex rules. Mathematicians call this method a “formal system” or a “calculus”. We can effectively write a formal system for Tetris if we wanted to. In fact, a working implementation of Tetris is a formal system, just specified using an unusual representation. A civilization of furry creatures on Alpha Centauri would not be able to read our formalisms of Tetris and circles because their only sensory input might be an organ that senses smells. They likely will never find out about the Tetris formalism, but they very well might have a formalism for circles. We probably wouldn’t be able to read it because our sense of smell isn’t that sophisticated, but once you get past the representation of the formalism (via various sensory instruments and standard code breaking techniques to understand the language), the concepts underneath are understandable to any intelligent civilization. Interestingly if no intelligent civilization ever existed in the universe the formalisms for Tetris and circles would still hold water, it’s just that nobody would be around to find out about them. If an intelligent civilization popped up, it would likely discover some formalisms that help describe the laws of our universe. They also would be very unlikely to ever find out about Tetris because there is nothing in the universe that resembles it. Tetris is one of countless examples of a formal system, a puzzle, that has nothing to do with the real world. We can’t even be sure that natural numbers have full resemblance to the real world, after all one can easily think of a number so big that it cannot describe anything in our universe since it might actually turn out to be finite. ###A Bit of History3Let’s shift gears in our time machine. This time we’ll travel a lot closer, to the 1930s. The Great Depression was ravaging the New and the Old worlds. Almost every family from every social class was affected by the tremendous economic downturn. Very few sanctuaries remained where people were safe from the perils of poverty. Few people were fortunate enough to be in these sanctuaries, but they did exist. Our interest lies in mathematicians in Princeton University. The new offices constructed in gothic style gave Princeton an aura of a safe haven. Logicians from all over the world were invited to Princeton to build out a new department. While most of America couldn’t find a piece of bread for dinner, high ceilings, walls covered with elaborately carved wood, daily discussions by a cup of tea, and walks in the forest were some of the conditions in Princeton.The new offices constructed in gothic style gave Princeton an aura of a safe haven. Logicians from all over the world were invited to Princeton to build out a new department. While most of America couldn’t find a piece of bread for dinner, high ceilings, walls covered with elaborately carved wood, daily discussions by a cup of tea, and walks in the forest were some of the conditions in Princeton. One mathematician living in such lavish lifestyle was a young man named Alonzo Church. Alonzo received a B.S. degree from Princeton and was persuaded to stay for graduate school. Alonzo felt the architecture was fancier than necessary. He rarely showed up to discuss mathematics with a cup of tea and he didn’t enjoy the walks in the woods. Alonzo was a loner: he was most productive when working on his own. Nevertheless Alonzo had regular contacts with other Princeton inhabitants. Among them were Alan Turing, John von Neumann, and Kurt Gödel. The four men were interested in formal systems. They didn’t pay much heed to the physical world, they were interested in dealing with abstract mathematical puzzles instead. Their puzzles had something in common: the men were working on answering questions about computation. If we had machines that had infinite computational power, what problems would we be able to solve? Could we solve them automatically? Could some problems remain unsolved and why? Would various machines with different designs be equal in power? In cooperation with other men Alonzo Church developed a formal system called lambda calculus. The system was essentially a programming language for one of these imaginary machines. It was based on functions that took other functions as parameters and returned functions as results. The function was identified by a Greek letter lambda, hence the system’s name4. Using this formalism Alonzo was able to reason about many of the above questions and provide conclusive answers. Independently of Alonzo Church, Alan Turing was performing similar work. He developed a different formalism (now referred to as the Turing machine), and used it to independently come to similar conclusions as Alonzo. Later it was shown that Turing machines and lambda calculus were equivalent in power. This is where the story would stop, I’d wrap up the article, and you’d navigate to another page, if not for the beginning of World War II. The world was in flames. The U.S. Army and Navy used artillery more often than ever. In attempts to improve accuracy the Army employed a large group of mathematicians to continuously calculate differential equations required for solving ballistic firing tables. It was becoming obvious that the task was too great for being solved manually and various equipment was developed in order to overcome this problem. The first machine to solve ballistic tables was a Mark I built by IBM - it weighed five tons, had 750,000 parts and could do three operations per second. The race, of course, wasn’t over. In 1949 an Electronic Discrete Variable Automatic Computer (EDVAC) was unveiled and had tremendous success. It was a first example of von Neumann’s architecture and was effectively a real world implementation of a Turing machine. For the time being Alonzo Church was out of luck. In late 1950s an MIT professor John McCarthy (also a Princeton graduate) developed interest in Alonzo Church’s work. In 1958 he unveiled a List Processing language (Lisp). Lisp was an implementation of Alonzo’s lambda calculus that worked on von Neumann computers! Many computer scientists recognized the expressive power of Lisp. In 1973 a group of programmers at MIT’s Artificial Intelligence Lab developed hardware they called a Lisp machine - effectively a native hardware implementation of Alonzo’s lambda calculus! Functional ProgrammingFunctional programming is a practical implementation of Alonzo Church’s ideas. Not all lambda calculus ideas transform to practice because lambda calculus was not designed to work under physical limitations. Therefore, like object oriented programming, functional programming is a set of ideas, not a set of strict guidelines. There are many functional programming languages, and most of them do many things very differently. In this article I will explain the most widely used ideas from functional languages using examples written in Java (yes, you could write functional programs in Java if you felt particularly masochistic). In the next couple of sections we’ll take Java as is, and will make modifications to it to transform it into a useable functional language. Let’s begin our quest. Lambda calculus was designed to investigate problems related to calculation. Functional programming, therefore, primarily deals with calculation, and, surprisingly, uses functions to do so. A function is a very basic unit in functional programming. Functions are used for almost everything, even the simplest of calculations. Even variables are replaced with functions. In functional programming variables are simply aliases for expressions (so we don’t have to type everything on one line). They cannot be modified. All variables can only be assigned to once. In Java terms this means that every single variable is declared as final (or const if we’re dealing with C++). There are no non-final variables in FP. 12final int i = 5;final int j = i + 3; Since every variable in FP is final two fairly interesting statements can be made. It does not make sense to always write the keyword final and it does not make sense to call variables, well… variables. We will now make two modifications to Java: every variable declared in our functional Java will be final by default, and we will refer to variables as symbols. By now you are probably wondering how you could possibly write anything reasonably complicated in our newly created language. If every symbol is non-mutable we cannot change the state of anything! This isn’t strictly true. When Alonzo was working on lambda calculus he wasn’t interested in maintaining state over periods of time in order to modify it later. He was interested in performing operations on data (also commonly referred to as “calculating stuff”). However, it was proved that lambda calculus is equivalent to a Turing machine. It can do all the same things an imperative programming language can. How, then, can we achieve the same results? It turns out that functional programs can keep state, except they don’t use variables to do it. They use functions instead. The state is kept in function parameters, on the stack. If you want to keep state for a while and every now and then modify it, you write a recursive function. As an example, let’s write a function that reverses a Java string. Remember, every variable we declare is final by default5. 12345678String reverse(String arg) &#123; if(arg.length == 0) &#123; return arg; &#125; else &#123; return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1); &#125;&#125; This function is slow because it repeatedly calls itself6. It’s a memory hog because it repeatedly allocates objects. But it’s functional in style. You may be interested why someone would want to program in this manner. Well, I was just about to tell you. ###Benefits of FPYou’re probably thinking that there’s no way I can rationalize the monstrosity of a function above. When I was learning functional programming I was thinking that too. I was wrong. There are very good arguments for using this style. Some of them are subjective. For example, people claim that functional programs are easier to understand. I will leave out these arguments because every kid on the block knows that ease of understanding is in the eye of the beholder. Fortunately for me, there are plenty of objective arguments. ####Unit TestingSince every symbol in FP is final, no function can ever cause side effects. You can never modify things in place, nor can one function modify a value outside of its scope for another function to use (like a class member or a global variable). That means that the only effect of evaluating a function is its return value and the only thing that affects the return value of a function is its arguments. This is a unit tester’s wet dream. You can test every function in your program only worrying about its arguments. You don’t have to worry about calling functions in the right order, or setting up external state properly. All you need to do is pass arguments that represent edge cases. If every function in your program passes unit tests you can be a lot more confident about quality of your software than if you were using an imperative language. In Java or C++ checking a return value of a function is not sufficient - it may modify external state that we would need to verify. Not so in a functional language. ####DebuggingIf a functional program doesn’t behave the way you expect it to, debugging it is a breeze. You will always be able to reproduce your problem because a bug in a functional program doesn’t depend on unrelated code paths that were executed before it. In an imperative program a bug resurfaces only some of the time. Because functions depend on external state produced by side effects from other functions you may have to go through a series of steps in no way related to the bug. In a functional program this isn’t the case - if a return value of a function is wrong, it is always wrong, regardless of what code you execute before running the function. Once you reproduce the problem, getting to the bottom of it is trivial. It is almost pleasant. You break the execution of your program and examine the stack. Every argument in every function call in the stack is available for your inspection, just like in an imperative program. Except in an imperative program that’s not enough because functions depend on member variables, global variables, and the state of other classes (which in turn depend on these very same things). A function in a functional program depends only on its arguments, and that information is right before your eyes! Furthermore, in an imperative program examining a return value of a function will not give you a good idea of whether the function behaves properly. You need to hunt down dozens of objects outside its scope to verify that it performed correct actions. In a functional program all you have to do is look at the return value! Walking through the stack you look at arguments passed to functions and their return values. The minute a return value doesn’t make sense you step into the offending function and walk through it. You repeat this recursively until the process leads you to the source of the bug! ####ConcurrencyA functional program is ready for concurrency without any further modifications. You never have to worry about deadlocks and race conditions because you don’t need to use locks! No piece of data in a functional program is modified twice by the same thread, let alone by two different threads. That means you can easily add threads without ever giving conventional problems that plague concurrency applications a second thought! If this is the case, why doesn’t anybody use functional programs for highly concurrent applications? Well, it turns out that they do. Ericsson designed a functional language called Erlang for use in its highly tolerant and scalable telecommunication switches. Many others recognized the benefits provided by Erlang and started using it. We’re talking about telecommunication and traffic control systems that are far more scalable and reliable than typical systems designed on Wall Street. Actually, Erlang systems are not scalable and reliable. Java systems are. Erlang systems are simply rock solid. The concurrency story doesn’t stop here. If your application is inherently single threaded the compiler can still optimize functional programs to run on multiple CPUs. Take a look at the following code fragment: 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); In a functional language the compiler could analyze the code, classify the functions that create strings s1 and s2 as potentially time consuming operations, and run them concurrently. This is impossible to do in an imperative language because each function may modify state outside of its scope and the function following it may depend on it. In functional languages automatic analysis of functions and finding good candidates for concurrent execution is as trivial as automatic inlining! In this sense functional style programs are “future proof” (as much as I hate buzzwords, I’ll indulge this time). Hardware manufacturers can no longer make CPUs run any faster. Instead they increase the number of cores and attribute quadruple speed increases to concurrency. Of course they conveniently forget to mention that we get our money’s worth only on software that deals with parallelizable problems. This is a very small fraction of imperative software but 100% of functional software because functional programs are all parallelizable out of the box. ####Hot Code DeploymentIn the old days of Windows in order to install updates it was necessary to restart the computer. Many times. After installing a newer version of a media players. With Windows XP the situation has improved significantly, yet it still isn’t ideal (I ran Windows Update at work today and now an annoying system tray icon won’t go away until I restart). Unix systems have had a better model for a while. In order to install an update you only need to stop relevant components, not the whole OS. While it is a better situation, for a large class of server applications it still isn’t acceptable. Telecommunication systems need to be up 100% of the time because if dialing emergency is not available due to upgrades, lives may be lost. There is no reason Wall Street firms need to bring down their systems to install software updates over the weekend. An ideal situation is updating relevant parts of the code without stopping any part of the system at all. In an imperative world this isn’t possible. Consider unloading a Java class at runtime and reloading a new definition. If we were to do that every instance of a class would become unusable because the state it holds would be lost. We would need to resort to writing tricky version control code. We’d need to serialize all running instances of the class, destroy them, create instances of the new class, try to load serialized data into them hoping the loading code properly migrates the data to work with the new instance. On top of that, every time we change something we’d have to write our migration code manually. And our migration code would have to take special care not to break relationships between objects. Nice in theory, but would never work well in practice. In a functional program all state is stored on the stack in the arguments passed to functions. This makes hot deployment significantly easier! In fact, all we’d really have to do is run a diff between the code in production and the new version, and deploy the new code. The rest could be done by language tools automatically! If you think this is science fiction, think again. Erlang engineers have been upgrading live systems without stopping them for years. ####Machine Assisted Proofs and OptimizationsAn interesting property of functional languages is that they can be reasoned about mathematically. Since a functional language is simply an implementation of a formal system, all mathematical operations that could be done on paper still apply to the programs written in that language. The compiler could, for example, convert pieces of code into equivalent but more efficient pieces with a mathematical proof that two pieces of code are equivalent7. Relational databases have been performing these optimizations for years. There is no reason the same techniques can’t apply to regular software. Additionally, you can use these techniques to prove that parts of your program are correct. It is even possible to create tools that analyze code and generate edge cases for unit tests automatically! This functionality is invaluable for rock solid systems. If you are designing pace makers and air traffic control systems such tools are almost always a requirement. If you are writing an application outside of truly mission critical industries, these tools can give you a tremendous edge over your competitors. ###Higher Order FunctionsI remember learning about the benefits I outlined above and thinking “that’s all very nice but it’s useless if I have to program in a crippled language where everything is final.” This was a misconception. Making all variables final is crippled in a context of an imperative language like Java but it isn’t in a context of functional languages. Functional languages offer a different kind of abstraction tools that make you forget you’ve ever liked modifying variables. One such tool is capability to work with higher order functions. A function in such languages is different from a function in Java or C. It is a superset - it can do all the things a Java function can do, and more. We create a function in the same manner we do in C: 123int add(int i, int j) &#123; return i + j;&#125; This means something different from equivalent C code. Let’s extend our Java compiler to support this notation. When we type something like this our compiler will convert it to the following Java code (don’t forget, everything is final): 1234567class add_function_t &#123; int add(int i, int j) &#123; return i + j; &#125;&#125;add_function_t add = new add_function_t(); The symbol add isn’t really a function. It is a small class with one function as its member. We can now pass add around in our code as an argument to other functions. We can assign it to another symbol. We can create instances of add_function_t at runtime and they will be garbage collected when we no longer need them. This makes functions first class objects no different from integers or strings. Functions that operate on other functions (accept them as arguments) are called higher order functions. Don’t let this term intimidate you, it’s no different from Java classes that operate on each other (we can pass class instances to other classes). We can call them “higher order classes” but nobody cares to because there is no strong academic community behind Java. How, and when, do you use higher order functions? Well, I’m glad you asked. You write your program as a big monolithic blob of code without worrying about class hierarchies. When you see that a particular piece of code is repeated, you break it out into a function (fortunately they still teach this in schools). If you see that a piece of logic within your function needs to behave differently in different situations, you break it out into a higher order function. Confused? Here’s a real life example from my work. Suppose we have a piece of Java code that receives a message, transforms it in various ways, and forwards it to another server. 1234567891011class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode("ABCD_123"); // ... sendMessage(msg); &#125; // ...&#125; Now imagine that our system has changed and we now route messages to two servers instead of one. Everything is handled in exactly the same way except the client code - the second server wants it in a different format. How do we handle this situation? We could check where the message is headed and format the client code differently, like this: 123456789101112131415class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... if(msg.getDestination().equals("server1") &#123; msg.setClientCode("ABCD_123"); &#125; else &#123; msg.setClientCode("123_ABC"); &#125; // ... sendMessage(msg); &#125; // ...&#125; This approach, however, isn’t scalable. If more servers are added our function will grow linearly and we’ll have a nightmare updating it. An object oriented approach is to make MessageHandler a base class and specialize the client code operation in derived classes: 12345678910111213141516171819202122232425abstract class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode(getClientCode()); // ... sendMessage(msg); &#125; abstract String getClientCode(); // ...&#125;class MessageHandlerOne extends MessageHandler &#123; String getClientCode() &#123; return "ABCD_123"; &#125;&#125;class MessageHandlerTwo extends MessageHandler &#123; String getClientCode() &#123; return "123_ABCD"; &#125;&#125; We can now instantiate an appropriate class for each server. Adding servers becomes much more maintainable. That’s a lot of code for such a simple modification though. We have to create two new types just to support different client codes! Now let’s do the same thing in our language that supports higher order functions: 12345678910111213141516171819202122class MessageHandler &#123; void handleMessage(Message msg, Function getClientCode) &#123; // ... Message msg1 = msg.setClientCode(getClientCode()); // ... sendMessage(msg1); &#125; // ...&#125;String getClientCodeOne() &#123; return "ABCD_123";&#125;String getClientCodeTwo() &#123; return "123_ABCD";&#125;MessageHandler handler = new MessageHandler();handler.handleMessage(someMsg, getClientCodeOne); We’ve created no new types and no class hierarchy. We simply pass appropriate functions as a parameter. We’ve achieved the same thing as the object oriented counterpart with a number of advantages. We don’t restrict ourselves to class hierarchies: we can pass new functions at runtime and change them at any time with a much higher degree of granularity with less code. Effectively the compiler has written object oriented “glue” code for us! In addition we get all the other benefits of FP. Of course the abstractions provided by functional languages don’t stop here. Higher order functions are just the beginning. ###CurryingMost people I’ve met have read the Design Patterns book by the Gang of Four. Any self respecting programmer will tell you that the book is language agnostic and the patterns apply to software engineering in general, regardless of which language you use. This is a noble claim. Unfortunately it is far removed from the truth. Functional languages are extremely expressive. In a functional language one does not need design patterns because the language is likely so high level, you end up programming in concepts that eliminate design patterns all together. Once such pattern is an Adapter pattern (how is it different from Facade again? Sounds like somebody needed to fill more pages to satisfy their contract). It is eliminated once a language supports a technique called currying. Adapter pattern is best known when applied to the “default” abstraction unit in Java - a class. In functional languages the pattern is applied to functions. The pattern takes an interface and transforms it to another interface someone else expects. Here’s an example of an adapter pattern: 12345int pow(int i, int j);int square(int i)&#123; return pow(i, 2);&#125; The code above adapts an interface of a function that raises an integer to an integer power to an interface of a function that squares an integer. In academic circles this trivial technique is called currying (after a logician Haskell Curry who performed mathematical acrobatics necessary to formalize it). Because in FP functions (as opposed to classes) are passed around as arguments, currying is used very often to adapt functions to an interface that someone else expects. Since the interface to functions is its arguments, currying is used to reduce the number of arguments (like in the example above). Functional languages come with this technique built in. You don’t need to manually create a function that wraps the original, functional languages will do that for you. As usual, let’s extend our language to support this technique. square = int pow(int i, 2);This will automatically create a function square for us with one argument. It will call pow function with the second argument set to 2. This will get compiled to the following Java code: 123456class square_function_t &#123; int square(int i) &#123; return pow(i, 2); &#125;&#125;square_function_t square = new square_function_t(); As you can see, we’ve simply created a wrapper for the original function. In FP currying is just that - a shortcut to quickly and easily create wrappers. You concentrate on your task, and the compiler writes the appropriate code for you! When do you use currying? This should be easy. Any time you’d like to use an adapter pattern (a wrapper). ####Lazy EvaluationLazy (or delayed) evaluation is an interesting technique that becomes possible once we adopt a functional philosophy. We’ve already seen the following piece of code when we were talking about concurrency: 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); In an imperative language the order of evaluation would be clear. Because each function may affect or depend on an external state it would be necessary to execute them in order: first somewhatLongOperation1, then somewhatLongOperation2, followed by concatenate. Not so in functional languages. As we saw earlier somewhatLongOperation1 and somewhatLongOperation2 can be executed concurrently because we’re guaranteed no function affects or depends on global state. But what if we don’t want to run the two concurrently, do we need to run them in order? The answer is no. We only need to run these operations when another function depends on s1 and s2. We don’t even have to run them before concatenate is called - we can delay their evaluation until they’re required within concatenate. If we replace concatenate with a function that has a conditional and uses only one of its two parameters we may never evaluate one of the parameters at all! Haskell is an example of a delayed evaluation language. In Haskell you are not guaranteed that anything will be executed in order (or at all) because Haskell only executes code when it’s required. Lazy evaluation has numerous advantages as well as disadvantages. We will discuss the advantages here and will explain how to counter the disadvantages in the next section. ####OptimizationLazy evaluation provides a tremendous potential for optimizations. A lazy compiler thinks of functional code exactly as mathematicians think of an algebra expression - it can cancel things out and completely prevent execution, rearrange pieces of code for higher efficiency, even arrange code in a way that reduces errors, all guaranteeing optimizations won’t break the code. This is the biggest benefit of representing programs strictly using formal primitives - code adheres to mathematical laws and can be reasoned about mathematically. ####Abstracting Control StructuresLazy evaluation provides a higher order of abstraction that allows implementing things in a way that would otherwise be impossible. For example consider implementing the following control structure: 123unless(stock.isEuropean()) &#123; sendToSEC(stock);&#125; We want sendToSEC executed unless the stock is European. How can we implement unless? Without lazy evaluation we’d need some form of a macro system, but in a language like Haskell that’s unnecessary. We can implement unless as a function! 1234void unless(boolean condition, List code) &#123; if(!condition) code;&#125; Note that code is never evaluated if the condition is true. We cannot reproduce this behavior in a strict language because the arguments would be evaluated before unless is entered. ####Infinite Data StructuresLazy languages allow for definition of infinite data structures, something that’s much more complicated in a strict language. For example, consider a list with Fibonacci numbers. We clearly can’t compute and infinite list in a reasonable amount of time or store it in memory. In strict languages like Java we simply define a Fibonacci function that returns a particular member from the sequence. In a language like Haskell we can abstract it further and simply define an infinite list of Fibonacci numbers. Because the language is lazy, only the necessary parts of the list that are actually used by the program are ever evaluated. This allows for abstracting a lot of problems and looking at them from a higher level (for example, we can use list processing functions on an infinite list). ####DisadvantagesOf course there ain’t no such thing as a free lunch(tm). Lazy evaluation comes with a number of disadvantages. Mainly that it is, well, lazy. Many real world problems require strict evaluation. For example consider the following: 12System.out.println("Please enter your name: ");System.in.readLine(); In a lazy language you have no guarantee that the first line will be executed before the second! This means we can’t do IO, can’t use native functions in any meaningful way (because they need to be called in order since they depend on side effects), and can’t interact with the outside world! If we were to introduce primitives that allow ordered code execution we’d lose the benefits of reasoning about our code mathematically (which would take all of the benefits of functional programming with it). Fortunately not all is lost. Mathematicians got to work and developed a number of tricks to ensure code gets executed in particular order in a functional setting. We get the best of both worlds! These techniques include continuations, monads, and uniqueness typing. In this article we’ll only deal with continuations. We’ll leave monads and uniqueness typing for another time. Interestingly, continuations are useful for many things other than enforcing a particular order of evaluation. We’ll talk about that as well. ###ContinuationsContinuations to programming are what Da Vinci Code is to human history: an amazing revelation of the greatest cover-up known to man. Well, may be not, but they’re certainly revealing of deceit in the same sense as square roots of negative numbers. When we learned about functions we only learned half truths based on a faulty assumption that functions must return their value to the original caller. In this sense continuations are a generalization of functions. A function must not necessarily return to its caller and may return to any part of the program. A “continuation” is a parameter we may choose to pass to our function that specifies where the function should return. The description may be more complicated than it sounds. Take a look at the following code: 12int i = add(5, 10);int j = square(i); The function add returns 15 to be assigned to i, the place where add was originally called. After that the value of i is used to call square. Note that a lazy compiler can’t rearrange these lines of code because the second line depends on successful evaluation of the first. We can rewrite this code block using Continuation Passing Style or CPS, where the function add doesn’t return to the original caller but instead returns its result to square. 1int j = add(5, 10, square); In this case add gets another parameter - a function that add must call with its result upon completion. In this case square is a continuation of add. In both cases j will equal 225. Here lays the first trick to force a lazy language to evaluate two expressions in order. Consider the following (familiar) IO code: 12System.out.println("Please enter your name: ");System.in.readLine(); The two lines don’t depend on each other and the compiler is free to rearrange them as it wishes. However, if we rewrite this code in CPS, there will be a dependency and the compiler will be forced to evaluate the two lines in order! System.out.println(“Please enter your name: “, System.in.readLine);In this case println needs to call readLine with its result and return the result of readLine. This allows us to ensure that the two lines are executed in order and that readLine is evaluated at all (because the whole computation expects the last value as a result). In case of Java println returns void but if it were to return an abstract value (that readLine would accept), we’d solve our problem! Of course chaining function calls like that will quickly become unreadable, but it isn’t necessary. We could add syntactic sugar to the language that will allow us to simply type expressions in order, and the compiler would chain the calls for us automatically. We can now evaluate expressions in any order we wish without losing any of the benefits of FP (including the ability to reason about our programs mathematically)! If this is still confusing, remember that a function is just an instance of a class with one member. Rewrite above two lines so that println and readLine are instances of classes and everything will become clear. I would now wrap up this section, except that we’ve only scratched the surface of continuations and their usefulness. We can write entire programs in CPS, where every function takes an extra continuation argument and passes the result to it. We can also convert any program to CPS simply by treating functions as special cases of continuations (functions that always return to their caller). This conversion is trivial to do automatically (in fact, many compilers do just that). Once we convert a program to CPS it becomes clear that every instruction has some continuation, a function it will call with the result, which in a regular program would be a place it must return to. Let’s pick any instruction from above code, say add(5, 10). In a program written in CPS style it’s clear what add’s continuation is - it’s a function that add calls once it’s done. But what is it in a non-CPS program? We could, of course, convert the program to CPS, but do we have to? It turns out that we don’t. Look carefully at our CPS conversion. If you try to write a compiler for it and think about it long enough you’ll realize that the CPS version needs no stack! No function ever “returns” in the traditional sense, it just calls another function with the result instead. We don’t need to push function arguments on the stack with every call and then pop them back, we can simply store them in some block of memory and use a jump instruction instead. We’ll never need the original arguments - they’ll never be used again since no function ever returns! So, programs written in CPS style have no stack but have an extra argument with a function to call. Programs not written in CPS style have no argument with a function to call, but have the stack instead. What does the stack contain? Simply the arguments, and a pointer to memory where the function should return. Do you see a light bulb? The stack simply contains continuation information! The pointer to the return instruction in the stack is essentially the same thing as the function to call in CPS programs! If you wanted to find out what continuation for add(5, 10) is, you’d simply have to examine the stack at the point of its execution! So that was easy. A continuation and a pointer to the return instruction in the stack are really the same thing, only a continuation is passed explicitly, so that it doesn’t need to be the same place where the function was called from. If you remember that a continuation is a function, and a function in our language is compiled to an instance of a class, you’ll realize that a pointer to the return instruction in the stack and the continuation argument are really the same thing, since our function (just like an instance of a class) is simply a pointer. This means that at any given point in time in your program you can ask for a current continuation (which is simply the information on the stack). Ok, so we know what a current continuation is. What does it mean? When we get a current continuation and store it somewhere, we end up storing the current state of our program - freezing it in time. This is similar to an OS putting itself into hibernation. A continuation object contains the information necessary to restart the program from the point where the continuation object was acquired. An operating system does this to your program all the time when it context switches between the threads. The only difference is that it keeps all the control. If you ask for a continuation object (in Scheme this is done by calling call-with-current-continuation function) you’ll get an object that contains the current continuation - the stack (or in a CPS case the function to call next). You can store this object in a variable (or alternatively, on disk). When you choose to “restart” your program with this continuation object you will “transform” to the state of the program when you grabbed the continuation object. It’s the same thing as switching back to a suspended thread or waking up an OS from hibernation, except you can do it again and again. When an OS wakes up, the hibernation information is destroyed. If it wasn’t, you’d be able to wake up from the same point over and over again, almost like going back in time. You have that control with continuations! In what situations are continuations useful? Usually when you’re trying to simulate state in an application of inherently stateless nature to ease your life. A great application of continuations are web applications. Microsoft’s ASP.NET goes to tremendous lengths to try and simulate state so that you can write your application with less hassle. If C# supported continuations half of ASP.NET’s complexity would disappear - you’d simply store a continuation and restart it when a user makes the web request again. To a programmer of the web application there would be no interruption - the program would simply start from the next line! Continuations are an incredibly useful abstraction for some problems. Considering that many of the traditional fat clients are moving to the web, continuations will become more and more important in the future. ###Pattern MatchingPattern matching is not a new or innovative feature. In fact, it has little to do with functional programming. The only reason why it’s usually attributed to FP is that functional languages have had pattern matching for some time, while modern imperative languages still don’t. Let’s dive into pattern matching with an example. Here’s a Fibonacci function in Java: 123456int fib(int n) &#123; if(n == 0) return 1; if(n == 1) return 1; return fib(n - 2) + fib(n - 1);&#125; And here’s an example of a Fibonacci function in our Java-derived language that supports pattern matching: 123456789int fib(0) &#123; return 1;&#125;int fib(1) &#123; return 1;&#125;int fib(int n) &#123; return fib(n - 2) + fib(n - 1);&#125; What’s the difference? The compiler implements branching for us. What’s the big deal? There isn’t any. Someone noticed that a large number of functions contain very complicated switch statements (this is particularly true about functional programs) and decided that it’s a good idea to abstract that away. We split the function definition into multiple ones, and put patterns in place of some arguments (sort of like overloading). When the function is called, the compiler compares the arguments with the definitions at runtime, and picks the correct one. This is usually done by picking the most specific definition available. For example, int fib(int n) can be called with n equal to 1, but it isn’t because int fib(1) is more specific. Pattern matching is usually more complex than our example reveals. For example, an advanced pattern matching system will allow us to do the following: 12int f(int n &lt; 10) &#123; ... &#125;int f(int n) &#123; ... &#125; When is pattern matching useful? In a surprisingly large number of cases! Every time you have a complex structure of nested ifs, pattern matching can do a better job with less code on your part. A good function that comes to mind is a standard WndProc function that all Win32 applications must provide (even though it’s often abstracted away). Usually a pattern matching system can examine collections as well as simple values. For example, if you pass an array to your function you could pick out all arrays in which the first element is equal to 1 and the third element is greater than 3. Another benefit of pattern matching is that if you need to add or modify conditions, you don’t have to go into one huge function. You simply add (or modify) appropriate definitions. This eliminates the need for a whole range of design patterns from the GoF book. The more complex your conditions are, the more pattern matching will help you. Once you’re used to it, you start wondering how you ever got through your day without it. ###ClosuresSo far we’ve discussed features in the context of “pure” functional languages - languages that are implementations of lambda calculus and don’t include features that conflict with Church’s formalism. However, many of the features of functional languages are useful outside of lambda calculus framework. While an implementation of an axiomatic system is useful because it allows thinking about programs in terms of mathematical expressions, it may or may not always be practical. Many languages choose to incorporate functional elements without strictly adhering to functional doctrine. Many such languages (like Common Lisp) don’t require variables to be final - you can modify things in place. They also don’t require functions to depend only on their arguments - functions are allowed to access state outside of their boundaries. But they do include functional features - like higher order functions. Passing functions around in impure languages is a little bit different than doing it in the confines of lambda calculus and requires support for an interesting feature often referred to as lexical closure. Let’s take a look at some sample code. Remember, in this case variables aren’t final and functions can refer to variables outside of their scope: 12345678910Function makePowerFn(int power) &#123; int powerFn(int base) &#123; return pow(base, power); &#125; return powerFn;&#125;Function square = makePowerFn(2);square(3); // returns 9 The function make-power-fn returns a function that takes a single argument and raises it to a certain power. What happens when we try to evaluate square(3)? The variable power isn’t anywhere in scope of powerFn because makePowerFn has returned and its stack is long gone. How can square work, then? The language must, somehow, store the value of power somewhere for square to work. What if we create another function, cube, that raises something to the third power? The runtime must now store two copies of power, one for each function we generated using make-power-fn. The phenomenon of storing these values is called a closure. Closures don’t only store arguments of a host function. For example, a closure can look like this: 1234567891011121314151617Function makeIncrementer() &#123; int n = 0; int increment() &#123; return ++n; &#125;&#125;Function inc1 = makeIncrementer();Function inc2 = makeIncrementer();inc1(); // returns 1;inc1(); // returns 2;inc1(); // returns 3;inc2(); // returns 1;inc2(); // returns 2;inc2(); // returns 3; The runtime manages to store n, so incrementers can access it. Furthermore, it stores various copies, one for each incrementer, even though they’re supposed to disappear when makeIncrementer returns. What does this code compile to? How do closures work behind the scenes? Fortunately, we have a back stage pass. A little common sense goes a long way. The first observation is that local variables are no longer limited to simple scope rules and have an undefined lifetime. The obvious conclusion is that they’re no longer stored on the stack - they must be stored on the heap instead8. A closure, then, is implemented just like a function we discussed earlier, except that it has an additional reference to the surrounding variables: 12345class some_function_t &#123; SymbolTable parentScope; // ...&#125; When a closure references a variable that’s not in its local scope, it consults this reference for a parent scope. That’s it! Closures bring functional and OO worlds closer together. Every time you create a class that holds some state and pass it to somewhere else, think of closures. A closure is just an object that creates “member variables” on the fly by grabbing them from the scope, so you don’t have to! ###What’s next?This article only scratches the surface of functional programming. Sometimes a small scratch can progress to something bigger and in our case it’s a good thing. In the future I plan to write about category theory, monads, functional data structures, type systems in functional languages, functional concurrency, functional databases and much more. If I get to write (and in the process learn) about half of these topics my life will be complete. In the meantime, Google is our friend. ###Comments?If you have any questions, comments, or suggestions, please drop a note at coffeemug@gmail.com. I’ll be glad to hear your feedback. 1When I was looking for a job in the fall of 2005 I often did ask this question. It’s quite amusing how many blank stares I got. You would think that at about $300,000 a piece these people would at least have a good understanding of most tools available to them.2This appears to be a controversial question. Physicists and mathematicians are forced to acknowledge that it isn’t at all clear whether everything in the universe obeys the laws that can be described by mathematics.3I’ve always hated history lessons that offer a dry chronology of dates, names, and events. To me history is about the lives of people who changed the world. It is about their private reasons behind their actions, and the mechanisms by which they affected millions of souls. For this reason this history section is hopelessly incomplete. Only very relevant people and events are discussed.4When I was learning about functional programming I was very annoyed by the term “lambda” because I couldn’t really understand what it really means. In this context lambda is a function, the single Greek letter was just easier to write in a mathematical notation. Every time you hear “lambda” when talking about functional programming just translate it in your mind to “function”.5Interestingly Java strings are immutable anyway. It’s rather interesting to explore the reasons for this treachery, but that would distract us from our goal.6Most functional language compilers optimize recursive functions by transforming them to their iterative alternatives whenever possible. This is called a tail call optimization.7The opposite isn’t always true. While it is sometimes possible to prove that two pieces of code are equivalent, it isn’t possible in all situations.8This is actually no slower than storing on the stack because once you introduce a garbage collector, memory allocation becomes an O(1) operation.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Functional</tag>
        <tag>Programming</tag>
        <tag>原文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5个简历模板下载及制作网站]]></title>
    <url>%2F2018%2F11%2F25%2F5%E4%B8%AA%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%88%B6%E4%BD%9C%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[不管是初入社会的菜鸟还是步入职场多年的老司机，你或许都需要一份能够代表自己的简历。 然而，大多数人都为简历的内容和设计伤透脑筋，或者在寻找模板的过程当中浪费太多时间，这里，我们为大家推荐几款还不错的简历模板下载和简历在线制作网站。 第一 基础 Office 模板其实，在 Office 的自带模板当中，是有一些最基础的简历模板的。以 Office 2016 为例，我们打开 Word，在这里搜索 “简历” ，找到适合自己的简历，选择【新建】，再对里面的内容进行修改就可以了。 第二 Office Plus如果 Office 自带基础模板不能够满足你的要求的话，微软官方还为我们提供了更多的在线模板，相比之下，这里选择更多，质量更高。最重要的是它们全都是免费的。 第三 五百丁五百丁，是一个非常方便的在线简历制作网站。 点击【免费制作简历】，五百丁为我们提供了非常多的模板样式，任意选择一个你喜欢的模板，开始编辑，在页面的左边，点击【板块管理】，这里的板块可以说是很全面的，你可以自行添加和删除。在【风格设置】这里，你可以对简历主题色、字体、字体大小、段距、板块距离等进行相应的调整。在简历当中，你同样可以对各板块进行修改、调整、删除等等。 编辑完成后，你可以将简历中的二维码保存，方便他人在手机上查看你的简历。另外，五百丁还支持简历投递，你可以在这里直接将简历投递给用人单位。 值得注意的是，如果你需要导出简历的话，需要最少 20 块人民币。 另外还有一个功能就是，扫描这里的二维码，就能够随时随地在手机上创作你的简历。 第四 简历本简历本的模板相比五百丁设计感稍弱，它可能更简洁，更加的商务风。简历内的模块和五百丁基本相同，只是设置位置有些不一样。编辑完成后，我们可以免费下载图片，PDF 文件前三次下载可以免费，如果要下载 Word 文档的话需要充值成为 VIP。除了简历制作，这个网站还为我们提供了【简历攻略】，在写作时或许可以为你提供帮助。 第五 乔布简历同样选择好模板，点击【使用此模板】，编辑好简历后，保存、下载 PDF 或者 Word 文档。但是它的下载都是需要付费的。 除了制作模板，乔布简历还提供【求职指南】，或许对你的求职过程会有很多帮助。 —————————————————–2018年7月23日写于归家途中 ennnnnnn，话说大一的下半学期我居然物理挂科了！想我那天还信心满满的第一个交卷，跟我室友说一定能过来着。唉……啪啪打脸，算了。补考咯]]></content>
      <categories>
        <category>高效率生活</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>模板</tag>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5个学术文献资料推荐网站]]></title>
    <url>%2F2018%2F11%2F25%2F5%E4%B8%AA%E5%AD%A6%E6%9C%AF%E6%96%87%E7%8C%AE%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[如果你在写作和查询论文的时候还在简单地使用百度搜索，想用知网又因为内容付费而望而却步，那么今天我们推荐的以下几个网站，也许可以帮到你。 国家哲学社会科学文献中心提供免费下载，提供各类哲学社会科学文献。 搜索功能强大，提供分类搜索、提名/关键词等搜索，也可以输入关键词进行查找。收录中外文学术期刊7000多种，还有图书、古籍，上线数据已超千万，内容丰富。 中国国家数字图书馆中国国家数字图书馆是中国国家图书馆的在线网站。它内置了文津搜索，可以搜索馆藏书，当然还能免费搜索到电子期刊，图书，论文，报纸，还有各种工具书等。 德国Springer-Verlag是世界著名科技出版集团，日前在国内开通了SpringerLink服务。SpringerLink所有资源划分为人文、生物、天文、物理等12个学科，提供海量相关期刊、图书、工具书查询，大部分图书支持免费下载PDF格式文件。 国家数据写论文的时候肯定会需要各种数据，比如某个省10年内的GDP或城镇化的数据之类的。有了这个网站，就再也不用担心论文木有数据支撑啦。 术语在线是由全国科学技术名词审定委员会主办的平台，基本上可以满足各个领域论文的术语检索要求，覆盖基础科学、工程与技术科学、农业科学、医学、人文社会科学、军事科学等各个领域的100余个学科。 当然，我们所推荐的也并非是最好最全的，更多优秀的网站希望得到广大粉丝的推荐，也等待需要这些内容的你，自己去发现。 ——————2018年7月28号、明天就要忙了，也不知道还有没有时间写博客。]]></content>
      <categories>
        <category>高效率生活</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>学术文献</tag>
        <tag>资料</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11个免费高清图片下载站]]></title>
    <url>%2F2018%2F11%2F25%2F11%E4%B8%AA%E5%85%8D%E8%B4%B9%E9%AB%98%E6%B8%85%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%AB%99%2F</url>
    <content type="text"><![CDATA[当你需要制作PPT、海报或者微信公众号图文，以及其他平面设计的时候，通常可能需要一些高清又好看的图片。然而除了百度，你还有其他找图的方式吗？视频中，我们提供了五大常用图片资源下载网站，下文，我列出了十一个清单。 NO.1 ｜ pexels-免费高清素材下载网站资源简介：免费高品质下载网是一提供海量共享素材的网站,每周都会定量更新,所有的都会显示详细的信息,例如拍摄的相机型号、光圈、焦距、ISO、大分辨率等。 使用方法：电脑登陆网址后，在搜索框内输入你要的图片关键词，当然是英文。不会英文怎么办？在线翻译工具很多呀，比如找办公室相关素材，关键词就是office，找商业相关的素材，输入business或commercial就可以了。 NO.2 ｜ unsplash-免费高清可商用摄影图片资源资源简介：高清无码、真人拍摄、可以免费商用，就是最大特点。其他的知道那么多搞毛啊！ 使用方法：“妈蛋！又是英文网站！” 是啊，又是英文。可你不用懂英文啊！浏览器中输入 https://unsplash.com/ ,然后找到搜索框，同样的，英文关键词搜索。不会英文随便找个在线词典、翻译即可。比如以下就是我们输入关键词 office 得到的结果。然后鼠标放在中意的图片上就会出现下载按钮，点击下载，待图片加载完成就可以右键保存了。 NO.3 ｜ stocksnap-免费高清可商用摄影图片资源资源简介：可自由下载使用的高清晰数码作品素材库，你随时都可以下载自己免费的资源。 使用方法：同样地，登录 https://stocksnap.io ，在巨大的搜索框中输入你要的图片关键词即可。还是那句话，英文不会，用在线翻译。找到中意图片之后，点击进入，然后点击红色download字样的按钮下载即可。 NO.4 ｜creative vix-免费高清可商用图片资源资源简介：高清无码、免费商用，如果还有一个特点，那就是网站好看。 使用方法：会基础英文的小年青们，找到搜索框，直接搜索去吧；不会的小年青，可以使用在线翻译工具。搜索英文关键词，海量图片随你拿。鼠标放在中意的图片上，点击download，图片加载完成后，右键另存即可。 NO.5 ｜ streetwill-免费高清可商用摄影图片资源资源简介：简单实用图片海量，主要是网站设计好看。 使用方法：登录 http://streetwill.co，英文有基础的可以通过分类查找自己的喜好，或者也可以直接搜索英文关键词。你问我搜索框在哪里？仔细看看，右上角。 NO.6 ｜ gratisography-免费高清创意图片资源资源简介：创意图片、海量高清、免费下载。和其他图片资源不同的是，这个网站的所有图片基本上都是创意图，有的是经过ps处理后的成品。 使用方法：随意浏览都能找到比较好的图片，如果针对性查找，当然还是关键词搜索。搜索框在哪儿呢？眼睛放亮，找一个叫做 magic auto search 的选框，输入关键词即可。鼠标放在中意的图片上，出现下载按钮，即可下载。 NO.7｜ textures-免费高清材质贴图资源资源简介：高清无码、真人拍摄、免费商用，主要用于一些材质贴图的查找，简而言之就是某物的表面样式。注册以后可以每天免费下载15张图片。 使用方法：网站左端有分类导航，英文基础ok的盆友可以通过导航查找。另外也可以通过英文关键词搜索。还是那句话，借助在线翻译器，翻译对应关键词搜索即可。找到相应的图片，点击图即可下载，可选择最多5种不同分辨率大小的图片。 NO.8｜ pixabay-免费高清矢量图片资源资源在哪：电脑端直接登录 https://pixabay.com 即可。 资源简介：矢量图是什么鬼？专业人员都知道。非专业人员在这里只需要了解，这样的图片一般来说不带背景，或者叫背景透明的图片。可以直接用于PPT、海报等制作中，不需要抠背景。这个网站提供大量这样的图片，免费高清、可直接下载。除了矢量图，pixabay也提供高清图片、高清视频、插画等等。 使用方法：哈，这次是中文了。找矢量图的时候，在搜索框输入矢量图关键词，搜索类型选择矢量图，点击搜索按钮即可。如下图就是我们搜索关键词office的到的矢量图。点击相应矢量图即可下载。 NO.9 ｜ designdeck-免费高清PSD、图标资源资源简介：大量免费的图标、PSD文件图，对UI设计非常有用，然而我们可以把眼界放开一点，不论是手机界面、电脑界面、PPT、海报等都可以是UI，不论是你专业人员还是普通人，如果有现成的各种图表、PSD文件可以使用，都能省了不少事儿。 使用方法：点击导航栏中的search，比如找iPhone相关的图标或PSD素材，输入iPhone点击搜索按钮即可。点击你看中的图片，进入后直接下拉到页面底部。绿色按钮表示购买，灰色按钮表示下载免费版本。看自己的需要进行选择就可以啦。 NO.10 ｜ flaticon-免费图标下载资源资源简介：PPT、UI设计等等，有图标直接使用就是事半功倍、如虎添翼。flaticon顾名思义就是扁平化图标。提供大量扁平化图标下载，基本上你所需要的都能找到。 使用方法：在搜索框输入你想要的图标关键词，比如手机，输入phone，搜索结果如下图，出现各种各样的图标。点击其中一个中意的，你可以选择最多四种格式如png、svg、eps、psd，一般情况下，非专业小年青想直接用于PPT等设计，直接选择png即可。之后可以选择七种不同大小。你可以选择左边的购买成套图标，也能选择右边的免费下载。官方会提示你最好署名作者的版权，并为你提供代码。点击free download即可下载。 NO.11 ｜ 别样网资源简介：别样网，是一家中国的场景公司，同样提供大量免费高清商用图片，除了遵从网站协议外，没有其他任何限制。另外，网站的UI设计也是非常不错的。 使用方法：中国的网站，没什么好说的，点击，下载。 —————————————2018年7月26号回家写的第一篇博客，好无聊啊]]></content>
      <categories>
        <category>高效率生活</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>高清</tag>
        <tag>图片</tag>
        <tag>下载</tag>
      </tags>
  </entry>
</search>
